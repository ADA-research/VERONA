{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"VERONA","text":"<p>VERONA is a lightweight Python package for setting up adversarial robustness experiments and to compute robustness distributions. The package implements adversarial attacks which can be extended with the auto-verify plugin to enable complete verification. </p>"},{"location":"#installation-and-environment-setup","title":"Installation and Environment Setup","text":""},{"location":"#create-virtual-environment-and-install-ada-verona","title":"Create Virtual Environment and install ada-verona","text":"<p>The python package for VERONA is called <code>ada-verona</code>, as our research group is called ADA.</p> <p>To run ada-verona, we recommend to set up a conda environment. We also recommend using miniforge as the package manager.</p> <p>Create a new conda environment named <code>verona_env</code>: <pre><code>conda create -n verona_env python=3.10\nconda activate verona_env\n</code></pre></p>"},{"location":"#installing-the-package","title":"Installing the package","text":"<p>Inside the conda environment, install the ada-verona package preferably using uv (fast Python package installer and resolver). Alternatively, you can install the package using pip only. <pre><code>uv pip install ada-verona\n</code></pre></p>"},{"location":"api/","title":"API","text":""},{"location":"api/#ada-verona","title":"ADA-VERONA","text":"<p>ADA-VERONA: Neural Network Robustness Analysis Framework</p> <p>A framework for analyzing neural network robustness through verification and adversarial testing.</p>"},{"location":"api/#ada_verona.AttackEstimationModule","title":"<code>AttackEstimationModule</code>","text":"<p>               Bases: <code>VerificationModule</code></p> <p>A module for estimating the robustness of a model against adversarial attacks.</p> Source code in <code>ada_verona/verification_module/attack_estimation_module.py</code> <pre><code>class AttackEstimationModule(VerificationModule):\n    \"\"\"\n    A module for estimating the robustness of a model against adversarial attacks.\n\n    \"\"\"\n\n    def __init__(self, attack: Attack) -&gt; None:\n        \"\"\"\n        Initialize the AttackEstimationModule with a specific attack.\n\n        Args:\n            attack (Attack): The attack to be used for robustness estimation.\n        \"\"\"\n        self.attack = attack\n        self.name = f\"AttackEstimationModule ({attack.name})\"\n\n    def verify(self, verification_context: VerificationContext, epsilon: float) -&gt; str | CompleteVerificationData:\n        \"\"\"\n        Verify the robustness of the model within the given epsilon perturbation.\n\n        Args:\n            verification_context (VerificationContext): The context for verification, \n            including the model and data point.\n            epsilon (float): The perturbation magnitude for the attack.\n\n        Returns:\n            str | CompleteVerificationData: The result of the verification,\n                                either SAT or UNSAT, along with the duration.\n        \"\"\"\n\n        if isinstance(verification_context.property_generator, One2AnyPropertyGenerator):\n            # Check if the property generator is of type One2AnyPropertyGenerator\n\n            start = time.time()  \n            torch_model = verification_context.network.load_pytorch_model() \n            device = 'cuda' if torch.cuda.is_available() else 'cpu'  \n            target = verification_context.data_point.label  \n            target_on_device = torch.tensor([target], device=device)  \n            data_on_device = verification_context.data_point.data.clone().detach().to(device)  \n            perturbed_data = self.attack.execute(torch_model, data_on_device, target_on_device, epsilon)  \n\n            output = torch_model(perturbed_data) \n\n            _, final_pred = output.max(1, keepdim=True)\n\n            duration = time.time() - start \n            if final_pred == target:\n                return CompleteVerificationData(result=VerificationResult.UNSAT, took=duration)\n            else:\n                return CompleteVerificationData(result=VerificationResult.SAT, took=duration)\n        else:\n            raise NotImplementedError(\"Currently, only one 2 any verification is implemented for adversarial attacks.\")\n</code></pre>"},{"location":"api/#ada_verona.AttackEstimationModule.__init__","title":"<code>__init__(attack)</code>","text":"<p>Initialize the AttackEstimationModule with a specific attack.</p> <p>Parameters:</p> Name Type Description Default <code>attack</code> <code>Attack</code> <p>The attack to be used for robustness estimation.</p> required Source code in <code>ada_verona/verification_module/attack_estimation_module.py</code> <pre><code>def __init__(self, attack: Attack) -&gt; None:\n    \"\"\"\n    Initialize the AttackEstimationModule with a specific attack.\n\n    Args:\n        attack (Attack): The attack to be used for robustness estimation.\n    \"\"\"\n    self.attack = attack\n    self.name = f\"AttackEstimationModule ({attack.name})\"\n</code></pre>"},{"location":"api/#ada_verona.AttackEstimationModule.verify","title":"<code>verify(verification_context, epsilon)</code>","text":"<p>Verify the robustness of the model within the given epsilon perturbation.</p> <p>Parameters:</p> Name Type Description Default <code>verification_context</code> <code>VerificationContext</code> <p>The context for verification, </p> required <code>epsilon</code> <code>float</code> <p>The perturbation magnitude for the attack.</p> required <p>Returns:</p> Type Description <code>str | CompleteVerificationData</code> <p>str | CompleteVerificationData: The result of the verification,                 either SAT or UNSAT, along with the duration.</p> Source code in <code>ada_verona/verification_module/attack_estimation_module.py</code> <pre><code>def verify(self, verification_context: VerificationContext, epsilon: float) -&gt; str | CompleteVerificationData:\n    \"\"\"\n    Verify the robustness of the model within the given epsilon perturbation.\n\n    Args:\n        verification_context (VerificationContext): The context for verification, \n        including the model and data point.\n        epsilon (float): The perturbation magnitude for the attack.\n\n    Returns:\n        str | CompleteVerificationData: The result of the verification,\n                            either SAT or UNSAT, along with the duration.\n    \"\"\"\n\n    if isinstance(verification_context.property_generator, One2AnyPropertyGenerator):\n        # Check if the property generator is of type One2AnyPropertyGenerator\n\n        start = time.time()  \n        torch_model = verification_context.network.load_pytorch_model() \n        device = 'cuda' if torch.cuda.is_available() else 'cpu'  \n        target = verification_context.data_point.label  \n        target_on_device = torch.tensor([target], device=device)  \n        data_on_device = verification_context.data_point.data.clone().detach().to(device)  \n        perturbed_data = self.attack.execute(torch_model, data_on_device, target_on_device, epsilon)  \n\n        output = torch_model(perturbed_data) \n\n        _, final_pred = output.max(1, keepdim=True)\n\n        duration = time.time() - start \n        if final_pred == target:\n            return CompleteVerificationData(result=VerificationResult.UNSAT, took=duration)\n        else:\n            return CompleteVerificationData(result=VerificationResult.SAT, took=duration)\n    else:\n        raise NotImplementedError(\"Currently, only one 2 any verification is implemented for adversarial attacks.\")\n</code></pre>"},{"location":"api/#ada_verona.BinarySearchEpsilonValueEstimator","title":"<code>BinarySearchEpsilonValueEstimator</code>","text":"<p>               Bases: <code>EpsilonValueEstimator</code></p> <p>A class to get the critical epsilon value using binary search.</p> Source code in <code>ada_verona/epsilon_value_estimator/binary_search_epsilon_value_estimator.py</code> <pre><code>class BinarySearchEpsilonValueEstimator(EpsilonValueEstimator):\n    \"\"\"\n    A class to get the critical epsilon value using binary search.\n    \"\"\"\n\n    def compute_epsilon_value(self, verification_context: VerificationContext) -&gt; EpsilonValueResult:\n        \"\"\"\n        Compute the epsilon value using binary search.\n\n        Args:\n            verification_context (VerificationContext): The context for verification.\n\n        Returns:\n            EpsilonValueResult: The result of the epsilon value estimation.\n        \"\"\"\n        epsilon_status_list = [EpsilonStatus(x, None, None, self.verifier.name) for x in self.epsilon_value_list]\n\n        start_time = time.time()\n        highest_unsat_value, smallest_sat_value = self.binary_search(verification_context, epsilon_status_list)\n        duration = time.time() - start_time\n        epsilon_value_result = EpsilonValueResult(\n            verification_context=verification_context,\n            epsilon=highest_unsat_value,\n            smallest_sat_value=smallest_sat_value,\n            time=duration,\n            verifier = self.verifier.name,\n        )\n\n        logger.info(\n            f\"Verification Context: {verification_context.get_dict_for_epsilon_result()}, \"\n            f\"epsilon_result: {epsilon_value_result.epsilon}\"  \n        )\n        return epsilon_value_result\n\n    def get_highest_unsat(self, epsilon_status_list: list[EpsilonStatus]) -&gt; float:\n        \"\"\"\n        Get the highest UNSAT epsilon value from the list.\n\n        Args:\n            epsilon_status_list (list[EpsilonStatus]): The list of epsilon statuses.\n\n        Returns:\n            float: The highest UNSAT epsilon value.\n        \"\"\"\n        highest_unsat = None\n        if len([x.result for x in epsilon_status_list if x.result == VerificationResult.UNSAT]) &gt; 0:\n            highest_unsat = max(\n                [index for index, x in enumerate(epsilon_status_list) if x.result == VerificationResult.UNSAT]\n            )\n\n        highest_unsat_value = epsilon_status_list[highest_unsat].value if highest_unsat is not None else 0\n\n        return highest_unsat_value\n\n    def get_smallest_sat(self, epsilon_status_list: list[EpsilonStatus]) -&gt; float:\n        \"\"\"\n        Get the smallest SAT epsilon value from the list.\n\n        Args:\n            epsilon_status_list (list[EpsilonStatus]): The list of epsilon statuses.\n\n        Returns:\n            float: The smallest SAT epsilon value.\n        \"\"\"\n        try:\n            max_epsilon_value = max([x.value for x in epsilon_status_list])\n        except ValueError:\n            return 0\n        smallest_sat = None\n\n        if len([x.result for x in epsilon_status_list if x.result == VerificationResult.SAT]) &gt; 0:\n            smallest_sat = min(\n                [index for index, x in enumerate(epsilon_status_list) if x.result == VerificationResult.SAT]\n            )\n\n        smallest_sat_value = epsilon_status_list[smallest_sat].value if smallest_sat is not None else max_epsilon_value\n\n        return smallest_sat_value\n\n    def binary_search(\n        self, verification_context: VerificationContext, epsilon_status_list: list[EpsilonStatus]\n    ) -&gt; float:\n        \"\"\"\n        Perform binary search to find the highest UNSAT and smallest SAT epsilon values.\n\n        Args:\n            verification_context (VerificationContext): The context for verification.\n            epsilon_status_list (list[EpsilonStatus]): The list of epsilon statuses.\n\n        Returns:\n            float: The highest UNSAT and smallest SAT epsilon values.\n        \"\"\"\n        if len(epsilon_status_list) == 1:\n            outcome = self.verifier.verify(verification_context, epsilon_status_list[0].value)\n            result = outcome.result\n            epsilon_status_list[0].time = outcome.took\n            epsilon_status_list[0].result = result\n            logger.debug(f\"current epsilon value: {epsilon_status_list[0].result}, took: {epsilon_status_list[0].time}\")\n            verification_context.save_result(epsilon_status_list[0])\n            if result == VerificationResult.UNSAT:\n                return epsilon_status_list[0].value, self.get_smallest_sat(epsilon_status_list)\n            else:\n                return 0, self.get_smallest_sat(epsilon_status_list)\n\n        first = 0\n        last = len(epsilon_status_list) - 1\n\n        while first &lt;= last:\n            midpoint = (first + last) // 2\n\n            if not epsilon_status_list[midpoint].result:\n                outcome = self.verifier.verify(verification_context, epsilon_status_list[midpoint].value)\n                epsilon_status_list[midpoint].result = outcome.result\n                epsilon_status_list[midpoint].time = outcome.took\n                verification_context.save_result(epsilon_status_list[midpoint])\n                logger.debug(\n                    f\"current epsilon value: {epsilon_status_list[midpoint].result},\"\n                    \"took: {epsilon_status_list[midpoint].time}\"  \n                )\n\n            if epsilon_status_list[midpoint].result == VerificationResult.UNSAT:\n                first = midpoint + 1\n            elif epsilon_status_list[midpoint].result == VerificationResult.SAT:\n                last = midpoint - 1\n            else:\n                epsilon_status_list.pop(midpoint)\n                last = last - 1\n\n        logger.debug(f\"epsilon status list: {[(x.value, x.result, x.time) for x in epsilon_status_list]}\")\n\n        highest_unsat_value = self.get_highest_unsat(epsilon_status_list)\n        smallest_sat_value = self.get_smallest_sat(epsilon_status_list)\n\n        return highest_unsat_value, smallest_sat_value\n</code></pre>"},{"location":"api/#ada_verona.BinarySearchEpsilonValueEstimator.binary_search","title":"<code>binary_search(verification_context, epsilon_status_list)</code>","text":"<p>Perform binary search to find the highest UNSAT and smallest SAT epsilon values.</p> <p>Parameters:</p> Name Type Description Default <code>verification_context</code> <code>VerificationContext</code> <p>The context for verification.</p> required <code>epsilon_status_list</code> <code>list[EpsilonStatus]</code> <p>The list of epsilon statuses.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The highest UNSAT and smallest SAT epsilon values.</p> Source code in <code>ada_verona/epsilon_value_estimator/binary_search_epsilon_value_estimator.py</code> <pre><code>def binary_search(\n    self, verification_context: VerificationContext, epsilon_status_list: list[EpsilonStatus]\n) -&gt; float:\n    \"\"\"\n    Perform binary search to find the highest UNSAT and smallest SAT epsilon values.\n\n    Args:\n        verification_context (VerificationContext): The context for verification.\n        epsilon_status_list (list[EpsilonStatus]): The list of epsilon statuses.\n\n    Returns:\n        float: The highest UNSAT and smallest SAT epsilon values.\n    \"\"\"\n    if len(epsilon_status_list) == 1:\n        outcome = self.verifier.verify(verification_context, epsilon_status_list[0].value)\n        result = outcome.result\n        epsilon_status_list[0].time = outcome.took\n        epsilon_status_list[0].result = result\n        logger.debug(f\"current epsilon value: {epsilon_status_list[0].result}, took: {epsilon_status_list[0].time}\")\n        verification_context.save_result(epsilon_status_list[0])\n        if result == VerificationResult.UNSAT:\n            return epsilon_status_list[0].value, self.get_smallest_sat(epsilon_status_list)\n        else:\n            return 0, self.get_smallest_sat(epsilon_status_list)\n\n    first = 0\n    last = len(epsilon_status_list) - 1\n\n    while first &lt;= last:\n        midpoint = (first + last) // 2\n\n        if not epsilon_status_list[midpoint].result:\n            outcome = self.verifier.verify(verification_context, epsilon_status_list[midpoint].value)\n            epsilon_status_list[midpoint].result = outcome.result\n            epsilon_status_list[midpoint].time = outcome.took\n            verification_context.save_result(epsilon_status_list[midpoint])\n            logger.debug(\n                f\"current epsilon value: {epsilon_status_list[midpoint].result},\"\n                \"took: {epsilon_status_list[midpoint].time}\"  \n            )\n\n        if epsilon_status_list[midpoint].result == VerificationResult.UNSAT:\n            first = midpoint + 1\n        elif epsilon_status_list[midpoint].result == VerificationResult.SAT:\n            last = midpoint - 1\n        else:\n            epsilon_status_list.pop(midpoint)\n            last = last - 1\n\n    logger.debug(f\"epsilon status list: {[(x.value, x.result, x.time) for x in epsilon_status_list]}\")\n\n    highest_unsat_value = self.get_highest_unsat(epsilon_status_list)\n    smallest_sat_value = self.get_smallest_sat(epsilon_status_list)\n\n    return highest_unsat_value, smallest_sat_value\n</code></pre>"},{"location":"api/#ada_verona.BinarySearchEpsilonValueEstimator.compute_epsilon_value","title":"<code>compute_epsilon_value(verification_context)</code>","text":"<p>Compute the epsilon value using binary search.</p> <p>Parameters:</p> Name Type Description Default <code>verification_context</code> <code>VerificationContext</code> <p>The context for verification.</p> required <p>Returns:</p> Name Type Description <code>EpsilonValueResult</code> <code>EpsilonValueResult</code> <p>The result of the epsilon value estimation.</p> Source code in <code>ada_verona/epsilon_value_estimator/binary_search_epsilon_value_estimator.py</code> <pre><code>def compute_epsilon_value(self, verification_context: VerificationContext) -&gt; EpsilonValueResult:\n    \"\"\"\n    Compute the epsilon value using binary search.\n\n    Args:\n        verification_context (VerificationContext): The context for verification.\n\n    Returns:\n        EpsilonValueResult: The result of the epsilon value estimation.\n    \"\"\"\n    epsilon_status_list = [EpsilonStatus(x, None, None, self.verifier.name) for x in self.epsilon_value_list]\n\n    start_time = time.time()\n    highest_unsat_value, smallest_sat_value = self.binary_search(verification_context, epsilon_status_list)\n    duration = time.time() - start_time\n    epsilon_value_result = EpsilonValueResult(\n        verification_context=verification_context,\n        epsilon=highest_unsat_value,\n        smallest_sat_value=smallest_sat_value,\n        time=duration,\n        verifier = self.verifier.name,\n    )\n\n    logger.info(\n        f\"Verification Context: {verification_context.get_dict_for_epsilon_result()}, \"\n        f\"epsilon_result: {epsilon_value_result.epsilon}\"  \n    )\n    return epsilon_value_result\n</code></pre>"},{"location":"api/#ada_verona.BinarySearchEpsilonValueEstimator.get_highest_unsat","title":"<code>get_highest_unsat(epsilon_status_list)</code>","text":"<p>Get the highest UNSAT epsilon value from the list.</p> <p>Parameters:</p> Name Type Description Default <code>epsilon_status_list</code> <code>list[EpsilonStatus]</code> <p>The list of epsilon statuses.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The highest UNSAT epsilon value.</p> Source code in <code>ada_verona/epsilon_value_estimator/binary_search_epsilon_value_estimator.py</code> <pre><code>def get_highest_unsat(self, epsilon_status_list: list[EpsilonStatus]) -&gt; float:\n    \"\"\"\n    Get the highest UNSAT epsilon value from the list.\n\n    Args:\n        epsilon_status_list (list[EpsilonStatus]): The list of epsilon statuses.\n\n    Returns:\n        float: The highest UNSAT epsilon value.\n    \"\"\"\n    highest_unsat = None\n    if len([x.result for x in epsilon_status_list if x.result == VerificationResult.UNSAT]) &gt; 0:\n        highest_unsat = max(\n            [index for index, x in enumerate(epsilon_status_list) if x.result == VerificationResult.UNSAT]\n        )\n\n    highest_unsat_value = epsilon_status_list[highest_unsat].value if highest_unsat is not None else 0\n\n    return highest_unsat_value\n</code></pre>"},{"location":"api/#ada_verona.BinarySearchEpsilonValueEstimator.get_smallest_sat","title":"<code>get_smallest_sat(epsilon_status_list)</code>","text":"<p>Get the smallest SAT epsilon value from the list.</p> <p>Parameters:</p> Name Type Description Default <code>epsilon_status_list</code> <code>list[EpsilonStatus]</code> <p>The list of epsilon statuses.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The smallest SAT epsilon value.</p> Source code in <code>ada_verona/epsilon_value_estimator/binary_search_epsilon_value_estimator.py</code> <pre><code>def get_smallest_sat(self, epsilon_status_list: list[EpsilonStatus]) -&gt; float:\n    \"\"\"\n    Get the smallest SAT epsilon value from the list.\n\n    Args:\n        epsilon_status_list (list[EpsilonStatus]): The list of epsilon statuses.\n\n    Returns:\n        float: The smallest SAT epsilon value.\n    \"\"\"\n    try:\n        max_epsilon_value = max([x.value for x in epsilon_status_list])\n    except ValueError:\n        return 0\n    smallest_sat = None\n\n    if len([x.result for x in epsilon_status_list if x.result == VerificationResult.SAT]) &gt; 0:\n        smallest_sat = min(\n            [index for index, x in enumerate(epsilon_status_list) if x.result == VerificationResult.SAT]\n        )\n\n    smallest_sat_value = epsilon_status_list[smallest_sat].value if smallest_sat is not None else max_epsilon_value\n\n    return smallest_sat_value\n</code></pre>"},{"location":"api/#ada_verona.EpsilonStatus","title":"<code>EpsilonStatus</code>  <code>dataclass</code>","text":"<p>A class to represent the status of the verification. It records the epsilon value, the result (SAT, UNSAT, TIMEOUT, ERROR) and running time.</p> Source code in <code>ada_verona/database/epsilon_status.py</code> <pre><code>@dataclass\nclass EpsilonStatus:\n    \"\"\"\n    A class to represent the status of the verification.\n    It records the epsilon value, the result (SAT, UNSAT, TIMEOUT, ERROR) and running time.\n    \"\"\"\n\n    value: float\n    result: VerificationResult | None\n    time: float = None\n    verifier: str = None\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"\n        Convert the EpsilonStatus to a dictionary.\n\n        Returns:\n            dict: The dictionary representation of the EpsilonStatus.\n        \"\"\"\n        return dict(epsilon_value=self.value, result=self.result, time=self.time, verifier=self.verifier)\n</code></pre>"},{"location":"api/#ada_verona.EpsilonStatus.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert the EpsilonStatus to a dictionary.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The dictionary representation of the EpsilonStatus.</p> Source code in <code>ada_verona/database/epsilon_status.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"\n    Convert the EpsilonStatus to a dictionary.\n\n    Returns:\n        dict: The dictionary representation of the EpsilonStatus.\n    \"\"\"\n    return dict(epsilon_value=self.value, result=self.result, time=self.time, verifier=self.verifier)\n</code></pre>"},{"location":"api/#ada_verona.EpsilonValueEstimator","title":"<code>EpsilonValueEstimator</code>","text":"<p>               Bases: <code>ABC</code></p> <p>An abstract base class for estimating epsilon values.</p> Source code in <code>ada_verona/epsilon_value_estimator/epsilon_value_estimator.py</code> <pre><code>class EpsilonValueEstimator(ABC):\n    \"\"\"\n    An abstract base class for estimating epsilon values.\n    \"\"\"\n\n    def __init__(self, epsilon_value_list: list[float], verifier: VerificationModule) -&gt; None:\n        \"\"\"\n        Initialize the EpsilonValueEstimator with the given epsilon value list and verifier.\n\n        Args:\n            epsilon_value_list (list[float]): The list of epsilon values to estimate.\n            verifier (VerificationModule): The verifier to use for verification.\n        \"\"\"\n        self.epsilon_value_list = epsilon_value_list\n        self.verifier = verifier\n\n    @abstractmethod\n    def compute_epsilon_value(self, verification_context: VerificationContext) -&gt; EpsilonValueResult:\n        \"\"\"\n        Compute the epsilon value for the given verification context.\n\n        Args:\n            verification_context (VerificationContext): The context for verification.\n\n        Returns:\n            EpsilonValueResult: The result of the epsilon value estimation.\n        \"\"\"\n        raise NotImplementedError(\"This is an abstract method and should be implemented in subclasses.\")\n</code></pre>"},{"location":"api/#ada_verona.EpsilonValueEstimator.__init__","title":"<code>__init__(epsilon_value_list, verifier)</code>","text":"<p>Initialize the EpsilonValueEstimator with the given epsilon value list and verifier.</p> <p>Parameters:</p> Name Type Description Default <code>epsilon_value_list</code> <code>list[float]</code> <p>The list of epsilon values to estimate.</p> required <code>verifier</code> <code>VerificationModule</code> <p>The verifier to use for verification.</p> required Source code in <code>ada_verona/epsilon_value_estimator/epsilon_value_estimator.py</code> <pre><code>def __init__(self, epsilon_value_list: list[float], verifier: VerificationModule) -&gt; None:\n    \"\"\"\n    Initialize the EpsilonValueEstimator with the given epsilon value list and verifier.\n\n    Args:\n        epsilon_value_list (list[float]): The list of epsilon values to estimate.\n        verifier (VerificationModule): The verifier to use for verification.\n    \"\"\"\n    self.epsilon_value_list = epsilon_value_list\n    self.verifier = verifier\n</code></pre>"},{"location":"api/#ada_verona.EpsilonValueEstimator.compute_epsilon_value","title":"<code>compute_epsilon_value(verification_context)</code>  <code>abstractmethod</code>","text":"<p>Compute the epsilon value for the given verification context.</p> <p>Parameters:</p> Name Type Description Default <code>verification_context</code> <code>VerificationContext</code> <p>The context for verification.</p> required <p>Returns:</p> Name Type Description <code>EpsilonValueResult</code> <code>EpsilonValueResult</code> <p>The result of the epsilon value estimation.</p> Source code in <code>ada_verona/epsilon_value_estimator/epsilon_value_estimator.py</code> <pre><code>@abstractmethod\ndef compute_epsilon_value(self, verification_context: VerificationContext) -&gt; EpsilonValueResult:\n    \"\"\"\n    Compute the epsilon value for the given verification context.\n\n    Args:\n        verification_context (VerificationContext): The context for verification.\n\n    Returns:\n        EpsilonValueResult: The result of the epsilon value estimation.\n    \"\"\"\n    raise NotImplementedError(\"This is an abstract method and should be implemented in subclasses.\")\n</code></pre>"},{"location":"api/#ada_verona.EpsilonValueResult","title":"<code>EpsilonValueResult</code>  <code>dataclass</code>","text":"<p>A dataclass defining the verification result of a single verification.</p> Source code in <code>ada_verona/database/epsilon_value_result.py</code> <pre><code>@dataclass\nclass EpsilonValueResult:\n    \"\"\"\n    A dataclass defining the verification result of a single verification.\n    \"\"\"\n\n    verification_context: VerificationContext\n    epsilon: float\n    smallest_sat_value: float\n    time: float = None\n    verifier: str = None\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"\n        Convert the EpsilonValueResult to a dictionary.\n\n        Returns:\n            dict: The dictionary representation of the EpsilonValueResult.\n        \"\"\"\n        ret = dict(\n            **self.verification_context.get_dict_for_epsilon_result(),\n            epsilon_value=self.epsilon,\n            smallest_sat_value=self.smallest_sat_value,\n            total_time=self.time,\n            verifier=self.verifier,\n        )\n        return ret\n</code></pre>"},{"location":"api/#ada_verona.EpsilonValueResult.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert the EpsilonValueResult to a dictionary.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The dictionary representation of the EpsilonValueResult.</p> Source code in <code>ada_verona/database/epsilon_value_result.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"\n    Convert the EpsilonValueResult to a dictionary.\n\n    Returns:\n        dict: The dictionary representation of the EpsilonValueResult.\n    \"\"\"\n    ret = dict(\n        **self.verification_context.get_dict_for_epsilon_result(),\n        epsilon_value=self.epsilon,\n        smallest_sat_value=self.smallest_sat_value,\n        total_time=self.time,\n        verifier=self.verifier,\n    )\n    return ret\n</code></pre>"},{"location":"api/#ada_verona.ExperimentRepository","title":"<code>ExperimentRepository</code>","text":"<p>Database to handle all the paths to the different files used.</p> Source code in <code>ada_verona/database/experiment_repository.py</code> <pre><code>class ExperimentRepository:\n    \"\"\"\n    Database to handle all the paths to the different files used.\n    \"\"\"\n\n    def __init__(self, base_path: Path, network_folder: Path) -&gt; None:\n        \"\"\"\n        Initialize the ExperimentRepository with the base path and network folder.\n\n        Args:\n            base_path (Path): The base path for the experiment repository.\n            network_folder (Path): The folder containing the network files.\n        \"\"\"\n        self.act_experiment_path = None\n        self.base_path = base_path\n        self.network_folder = network_folder\n\n    def get_act_experiment_path(self) -&gt; Path:\n        \"\"\"\n        Get the path to the active experiment.\n\n        Returns:\n            Path: The path to the active experiment.\n\n        Raises:\n            Exception: If no experiment is loaded.\n        \"\"\"\n        if self.act_experiment_path is not None:\n            return self.act_experiment_path\n        else:\n            raise Exception(\"No experiment loaded\")\n\n    def get_results_path(self) -&gt; Path:\n        \"\"\"\n        Get the path to the results folder of the active experiment.\n\n        Returns:\n            Path: The path to the results folder.\n        \"\"\"\n        return self.get_act_experiment_path() / \"results\"\n\n    def get_tmp_path(self) -&gt; Path:\n        \"\"\"\n        Get the path to the temporary folder of the active experiment.\n\n        Returns:\n            Path: The path to the temporary folder.\n        \"\"\"\n        return self.get_act_experiment_path() / \"tmp\"\n\n    def initialize_new_experiment(self, experiment_name: str) -&gt; None:\n        \"\"\"\n        Initialize a new experiment with the given name.\n\n        Args:\n            experiment_name (str): The name of the experiment.\n\n        Raises:\n            Exception: If a directory with the same name already exists.\n        \"\"\"\n        now = datetime.now()\n        now_string = now.strftime(\"%d-%m-%Y+%H_%M\")\n\n        self.act_experiment_path = self.base_path / f\"{experiment_name}_{now_string}\"\n\n        if os.path.exists(self.get_results_path()):\n            raise Exception(\n                \"Error, there is already a directory with results with the same name,\"\n                \"make sure no results will be overwritten\"  \n            )\n        else:\n            os.makedirs(self.get_results_path())\n        os.makedirs(self.get_tmp_path())\n\n    def load_experiment(self, experiment_name: str) -&gt; None:\n        \"\"\"\n        Load an existing experiment with the given name.\n\n        Args:\n            experiment_name (str): The name of the experiment.\n        \"\"\"\n        self.act_experiment_path = self.base_path / experiment_name\n\n    def save_configuration(self, data: dict) -&gt; None:\n        \"\"\"\n        Save the configuration data to a JSON file.\n\n        Args:\n            data (dict): The configuration data to save.\n        \"\"\"\n        with open(self.get_act_experiment_path() / \"configuration.json\", \"w\") as outfile:\n            json.dump(data, outfile)\n\n    def get_network_list(self, csv_name: str = None) -&gt; list[Network]:\n        \"\"\"\n        Return a list of networks either from a CSV (preferred) or by scanning\n        the network folder for ONNX files if CSV loading fails.\n\n        Args:\n            csv_name: Optional custom CSV filename.\n\n        Returns:\n            list[Network]: The list of networks.\n        \"\"\"\n        csv_path = self.network_folder / (csv_name or DEFAULT_NETWORKS_CSV_NAME)\n\n        def try_load_csv(path):\n            try:\n                return self.load_networks_from_csv(path)\n            except Exception as e:\n                print(f\"Warning: Could not load networks from CSV '{path}': {e}\")\n                print(\"Falling back to directory scanning for ONNX files.\")\n                return None\n\n        if csv_path.exists():\n            networks = try_load_csv(csv_path)\n            if networks is not None:\n                return networks\n\n        return [Network.from_file({\"architecture\": p, \"network_type\": \"onnx\"}) \n                for p in self.network_folder.iterdir() \n                if p.suffix == \".onnx\"]\n\n    def load_networks_from_csv(self, network_csv_path: str) -&gt; list[Network]:\n        \"\"\"\n        Load networks from a CSV file.\n\n        Args:\n            network_csv_path: Path to the CSV file.\n\n        Returns:\n            List of Network objects to use for experiments.\n        \"\"\"\n        try:\n            df = pd.read_csv(network_csv_path)\n        except (pd.errors.EmptyDataError, pd.errors.ParserError) as e:\n            msg = (\n                f\"Networks CSV file is empty: {network_csv_path}\"\n                if isinstance(e, pd.errors.EmptyDataError)\n                else f\"Error parsing networks CSV file: {e}\"\n            )\n            raise ValueError(msg) from None\n\n        missing = [c for c in [\"architecture\", \"network_type\"] if c not in df.columns]\n        if missing:\n            raise ValueError(f\"Missing required columns in networks CSV: {missing}\")\n\n        networks = []\n        for _, row in df.iterrows():\n            try:\n                networks.append(self.load_network_from_csv_row(row))\n            except Exception as e:\n                raise ValueError(\n                    f\"Error creating network from row {row.to_dict()}: {e}\"\n                ) from e\n\n        return networks\n\n    def load_network_from_csv_row(self, row: pd.Series) -&gt; Network:\n        \"\"\"\n            Load information from a single row and instantiate the Network via the abstract class. \n\n            Returns:\n                Loaded Network\n        \"\"\"\n        architecture = row.get(\"architecture\", None)\n        if architecture is None or pd.isna(architecture) or str(architecture).strip() == \"\":\n            raise ValueError(\"All network types require 'architecture' field\")\n\n        arch = Path(architecture)\n        args = {\n            \"architecture\": arch,\n            \"network_type\": row[\"network_type\"],\n        }\n\n        if \"weights\" in row and pd.notna(row[\"weights\"]) and str(row[\"weights\"]).strip():\n            args[\"weights\"] = Path(row[\"weights\"])\n\n\n        return Network.from_file(args)\n\n\n    def save_results(self, results: list[EpsilonValueResult]) -&gt; None:\n        \"\"\"\n        Save the list of epsilon value results to a CSV file.\n\n        Args:\n            results (list[EpsilonValueResult]): The list of epsilon value results to save.\n        \"\"\"\n        result_df = pd.DataFrame([x.to_dict() for x in results])\n        result_df.to_csv(self.get_results_path() / DEFAULT_RESULT_CSV_NAME)\n\n    def save_result(self, result: EpsilonValueResult) -&gt; None:\n        \"\"\"\n        Save a single epsilon value result to the CSV file.\n\n        Args:\n            result (EpsilonValueResult): The epsilon value result to save.\n        \"\"\"\n        result_df_path = self.get_results_path() / DEFAULT_RESULT_CSV_NAME\n        if result_df_path.exists():\n            df = pd.read_csv(result_df_path, index_col=0)\n            df.loc[len(df.index)] = result.to_dict()\n        else:\n            df = pd.DataFrame([result.to_dict()])\n        df.to_csv(result_df_path)\n\n    def get_file_name(self, file: Path) -&gt; str:\n        \"\"\"\n        Get the name of the file without the extension.\n\n        Args:\n            file (Path): The file path.\n\n        Returns:\n            str: The name of the file without the extension.\n        \"\"\"\n        return file.name.split(\".\")[0]\n\n    def create_verification_context(\n        self, network: Network, data_point: DataPoint, property_generator: PropertyGenerator\n    ) -&gt; VerificationContext:\n        \"\"\"\n        Create a verification context for the given network, data point, and property generator.\n\n        Args:\n            network (Network): The network to verify.\n            data_point (DataPoint): The data point to verify.\n            property_generator (PropertyGenerator): The property generator to use.\n\n        Returns:\n            VerificationContext: The created verification context.\n        \"\"\"\n        tmp_path = self.get_tmp_path() / f\"{self.get_file_name(network.path)}\" / f\"image_{data_point.id}\"\n        return VerificationContext(network, data_point, tmp_path, property_generator)\n\n    def get_result_df(self) -&gt; pd.DataFrame:\n        \"\"\"\n        Get the result DataFrame from the results CSV file.\n\n        Returns:\n            pd.DataFrame: The result DataFrame.\n\n        Raises:\n            Exception: If no result file is found.\n        \"\"\"\n        result_df_path = self.get_results_path() / DEFAULT_RESULT_CSV_NAME\n        if result_df_path.exists():\n            df = pd.read_csv(result_df_path, index_col=0)\n            df[\"network\"] = df.network_path.str.split(\"/\").apply(lambda x: x[-1]).apply(lambda x: x.split(\".\")[0])\n\n            return df\n        else:\n            raise Exception(f\"Error, no result file found at {result_df_path}\")\n\n    def get_per_epsilon_result_df(self) -&gt; pd.DataFrame:\n        \"\"\"\n        Get the per-epsilon result DataFrame from the temporary folder.\n\n        Returns:\n            pd.DataFrame: The per-epsilon result DataFrame.\n        \"\"\"\n        per_epsilon_result_df_name = \"epsilons_df.csv\"\n        df = pd.DataFrame()\n        network_folders = [x for x in self.get_tmp_path().iterdir()]\n        for network_folder in network_folders:\n            images_folders = [x for x in network_folders[0].iterdir()]\n            for image_folder in images_folders:\n                t_df = pd.read_csv(image_folder / per_epsilon_result_df_name, index_col=0)\n                t_df[\"network\"] = network_folder.name\n                t_df[\"image\"] = image_folder.name\n                df = pd.concat([df, t_df])\n        return df\n\n    def save_per_epsilon_result_df(self) -&gt; None:\n        \"\"\"\n        Save the per-epsilon result DataFrame to a CSV file.\n        \"\"\"\n        per_epsilon_result_df = self.get_per_epsilon_result_df()\n        per_epsilon_result_df.to_csv(self.get_results_path() / PER_EPSILON_RESULT_CSV_NAME)\n\n    def save_plots(self) -&gt; None:\n        \"\"\"\n        Save the plots generated from the result DataFrame.\n        \"\"\"\n        df = self.get_result_df()\n        report_creator = ReportCreator(df)\n        hist_figure = report_creator.create_hist_figure()\n        hist_figure.savefig(self.get_results_path() / \"hist_figure.png\", bbox_inches=\"tight\")\n\n        boxplot = report_creator.create_box_figure()\n        boxplot.savefig(self.get_results_path() / \"boxplot.png\", bbox_inches=\"tight\")\n\n        kde_figure = report_creator.create_kde_figure()\n        kde_figure.savefig(self.get_results_path() / \"kde_plot.png\", bbox_inches=\"tight\")\n\n        ecdf_figure = report_creator.create_ecdf_figure()\n        ecdf_figure.savefig(self.get_results_path() / \"ecdf_plot.png\", bbox_inches=\"tight\")\n\n    def save_verification_context_to_yaml(self, file_path: Path, verification_context: VerificationContext) -&gt; Path:\n        \"\"\"\n        Save the verification context to a YAML file.\n\n        Args:\n            file_path (Path): The path to save the YAML file.\n            verification_context (VerificationContext): The verification context to save.\n\n        Returns:\n            Path: The path to the saved YAML file.\n        \"\"\"\n        with open(file_path, \"w\") as file:\n            yaml.dump(verification_context.to_dict(), file)\n        return file_path\n\n    def load_verification_context_from_yaml(self, file_path: Path) -&gt; VerificationContext:\n        \"\"\"\n        Load the verification context from a YAML file.\n\n        Args:\n            file_path (Path): The path to the YAML file.\n\n        Returns:\n            VerificationContext: The loaded verification context.\n        \"\"\"\n        with open(file_path) as file:\n            data = yaml.safe_load(file)\n            return VerificationContext.from_dict(data)\n\n    def cleanup_tmp_directory(self):\n        \"\"\"\n        Delete the temporary folder of the active experiment.\n        \"\"\"\n\n        tmp_path = self.get_tmp_path()\n        if tmp_path.exists():\n            for file in tmp_path.iterdir():\n                file.unlink()\n            tmp_path.rmdir()\n</code></pre>"},{"location":"api/#ada_verona.ExperimentRepository.__init__","title":"<code>__init__(base_path, network_folder)</code>","text":"<p>Initialize the ExperimentRepository with the base path and network folder.</p> <p>Parameters:</p> Name Type Description Default <code>base_path</code> <code>Path</code> <p>The base path for the experiment repository.</p> required <code>network_folder</code> <code>Path</code> <p>The folder containing the network files.</p> required Source code in <code>ada_verona/database/experiment_repository.py</code> <pre><code>def __init__(self, base_path: Path, network_folder: Path) -&gt; None:\n    \"\"\"\n    Initialize the ExperimentRepository with the base path and network folder.\n\n    Args:\n        base_path (Path): The base path for the experiment repository.\n        network_folder (Path): The folder containing the network files.\n    \"\"\"\n    self.act_experiment_path = None\n    self.base_path = base_path\n    self.network_folder = network_folder\n</code></pre>"},{"location":"api/#ada_verona.ExperimentRepository.cleanup_tmp_directory","title":"<code>cleanup_tmp_directory()</code>","text":"<p>Delete the temporary folder of the active experiment.</p> Source code in <code>ada_verona/database/experiment_repository.py</code> <pre><code>def cleanup_tmp_directory(self):\n    \"\"\"\n    Delete the temporary folder of the active experiment.\n    \"\"\"\n\n    tmp_path = self.get_tmp_path()\n    if tmp_path.exists():\n        for file in tmp_path.iterdir():\n            file.unlink()\n        tmp_path.rmdir()\n</code></pre>"},{"location":"api/#ada_verona.ExperimentRepository.create_verification_context","title":"<code>create_verification_context(network, data_point, property_generator)</code>","text":"<p>Create a verification context for the given network, data point, and property generator.</p> <p>Parameters:</p> Name Type Description Default <code>network</code> <code>Network</code> <p>The network to verify.</p> required <code>data_point</code> <code>DataPoint</code> <p>The data point to verify.</p> required <code>property_generator</code> <code>PropertyGenerator</code> <p>The property generator to use.</p> required <p>Returns:</p> Name Type Description <code>VerificationContext</code> <code>VerificationContext</code> <p>The created verification context.</p> Source code in <code>ada_verona/database/experiment_repository.py</code> <pre><code>def create_verification_context(\n    self, network: Network, data_point: DataPoint, property_generator: PropertyGenerator\n) -&gt; VerificationContext:\n    \"\"\"\n    Create a verification context for the given network, data point, and property generator.\n\n    Args:\n        network (Network): The network to verify.\n        data_point (DataPoint): The data point to verify.\n        property_generator (PropertyGenerator): The property generator to use.\n\n    Returns:\n        VerificationContext: The created verification context.\n    \"\"\"\n    tmp_path = self.get_tmp_path() / f\"{self.get_file_name(network.path)}\" / f\"image_{data_point.id}\"\n    return VerificationContext(network, data_point, tmp_path, property_generator)\n</code></pre>"},{"location":"api/#ada_verona.ExperimentRepository.get_act_experiment_path","title":"<code>get_act_experiment_path()</code>","text":"<p>Get the path to the active experiment.</p> <p>Returns:</p> Name Type Description <code>Path</code> <code>Path</code> <p>The path to the active experiment.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If no experiment is loaded.</p> Source code in <code>ada_verona/database/experiment_repository.py</code> <pre><code>def get_act_experiment_path(self) -&gt; Path:\n    \"\"\"\n    Get the path to the active experiment.\n\n    Returns:\n        Path: The path to the active experiment.\n\n    Raises:\n        Exception: If no experiment is loaded.\n    \"\"\"\n    if self.act_experiment_path is not None:\n        return self.act_experiment_path\n    else:\n        raise Exception(\"No experiment loaded\")\n</code></pre>"},{"location":"api/#ada_verona.ExperimentRepository.get_file_name","title":"<code>get_file_name(file)</code>","text":"<p>Get the name of the file without the extension.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>Path</code> <p>The file path.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The name of the file without the extension.</p> Source code in <code>ada_verona/database/experiment_repository.py</code> <pre><code>def get_file_name(self, file: Path) -&gt; str:\n    \"\"\"\n    Get the name of the file without the extension.\n\n    Args:\n        file (Path): The file path.\n\n    Returns:\n        str: The name of the file without the extension.\n    \"\"\"\n    return file.name.split(\".\")[0]\n</code></pre>"},{"location":"api/#ada_verona.ExperimentRepository.get_network_list","title":"<code>get_network_list(csv_name=None)</code>","text":"<p>Return a list of networks either from a CSV (preferred) or by scanning the network folder for ONNX files if CSV loading fails.</p> <p>Parameters:</p> Name Type Description Default <code>csv_name</code> <code>str</code> <p>Optional custom CSV filename.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[Network]</code> <p>list[Network]: The list of networks.</p> Source code in <code>ada_verona/database/experiment_repository.py</code> <pre><code>def get_network_list(self, csv_name: str = None) -&gt; list[Network]:\n    \"\"\"\n    Return a list of networks either from a CSV (preferred) or by scanning\n    the network folder for ONNX files if CSV loading fails.\n\n    Args:\n        csv_name: Optional custom CSV filename.\n\n    Returns:\n        list[Network]: The list of networks.\n    \"\"\"\n    csv_path = self.network_folder / (csv_name or DEFAULT_NETWORKS_CSV_NAME)\n\n    def try_load_csv(path):\n        try:\n            return self.load_networks_from_csv(path)\n        except Exception as e:\n            print(f\"Warning: Could not load networks from CSV '{path}': {e}\")\n            print(\"Falling back to directory scanning for ONNX files.\")\n            return None\n\n    if csv_path.exists():\n        networks = try_load_csv(csv_path)\n        if networks is not None:\n            return networks\n\n    return [Network.from_file({\"architecture\": p, \"network_type\": \"onnx\"}) \n            for p in self.network_folder.iterdir() \n            if p.suffix == \".onnx\"]\n</code></pre>"},{"location":"api/#ada_verona.ExperimentRepository.get_per_epsilon_result_df","title":"<code>get_per_epsilon_result_df()</code>","text":"<p>Get the per-epsilon result DataFrame from the temporary folder.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: The per-epsilon result DataFrame.</p> Source code in <code>ada_verona/database/experiment_repository.py</code> <pre><code>def get_per_epsilon_result_df(self) -&gt; pd.DataFrame:\n    \"\"\"\n    Get the per-epsilon result DataFrame from the temporary folder.\n\n    Returns:\n        pd.DataFrame: The per-epsilon result DataFrame.\n    \"\"\"\n    per_epsilon_result_df_name = \"epsilons_df.csv\"\n    df = pd.DataFrame()\n    network_folders = [x for x in self.get_tmp_path().iterdir()]\n    for network_folder in network_folders:\n        images_folders = [x for x in network_folders[0].iterdir()]\n        for image_folder in images_folders:\n            t_df = pd.read_csv(image_folder / per_epsilon_result_df_name, index_col=0)\n            t_df[\"network\"] = network_folder.name\n            t_df[\"image\"] = image_folder.name\n            df = pd.concat([df, t_df])\n    return df\n</code></pre>"},{"location":"api/#ada_verona.ExperimentRepository.get_result_df","title":"<code>get_result_df()</code>","text":"<p>Get the result DataFrame from the results CSV file.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: The result DataFrame.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If no result file is found.</p> Source code in <code>ada_verona/database/experiment_repository.py</code> <pre><code>def get_result_df(self) -&gt; pd.DataFrame:\n    \"\"\"\n    Get the result DataFrame from the results CSV file.\n\n    Returns:\n        pd.DataFrame: The result DataFrame.\n\n    Raises:\n        Exception: If no result file is found.\n    \"\"\"\n    result_df_path = self.get_results_path() / DEFAULT_RESULT_CSV_NAME\n    if result_df_path.exists():\n        df = pd.read_csv(result_df_path, index_col=0)\n        df[\"network\"] = df.network_path.str.split(\"/\").apply(lambda x: x[-1]).apply(lambda x: x.split(\".\")[0])\n\n        return df\n    else:\n        raise Exception(f\"Error, no result file found at {result_df_path}\")\n</code></pre>"},{"location":"api/#ada_verona.ExperimentRepository.get_results_path","title":"<code>get_results_path()</code>","text":"<p>Get the path to the results folder of the active experiment.</p> <p>Returns:</p> Name Type Description <code>Path</code> <code>Path</code> <p>The path to the results folder.</p> Source code in <code>ada_verona/database/experiment_repository.py</code> <pre><code>def get_results_path(self) -&gt; Path:\n    \"\"\"\n    Get the path to the results folder of the active experiment.\n\n    Returns:\n        Path: The path to the results folder.\n    \"\"\"\n    return self.get_act_experiment_path() / \"results\"\n</code></pre>"},{"location":"api/#ada_verona.ExperimentRepository.get_tmp_path","title":"<code>get_tmp_path()</code>","text":"<p>Get the path to the temporary folder of the active experiment.</p> <p>Returns:</p> Name Type Description <code>Path</code> <code>Path</code> <p>The path to the temporary folder.</p> Source code in <code>ada_verona/database/experiment_repository.py</code> <pre><code>def get_tmp_path(self) -&gt; Path:\n    \"\"\"\n    Get the path to the temporary folder of the active experiment.\n\n    Returns:\n        Path: The path to the temporary folder.\n    \"\"\"\n    return self.get_act_experiment_path() / \"tmp\"\n</code></pre>"},{"location":"api/#ada_verona.ExperimentRepository.initialize_new_experiment","title":"<code>initialize_new_experiment(experiment_name)</code>","text":"<p>Initialize a new experiment with the given name.</p> <p>Parameters:</p> Name Type Description Default <code>experiment_name</code> <code>str</code> <p>The name of the experiment.</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>If a directory with the same name already exists.</p> Source code in <code>ada_verona/database/experiment_repository.py</code> <pre><code>def initialize_new_experiment(self, experiment_name: str) -&gt; None:\n    \"\"\"\n    Initialize a new experiment with the given name.\n\n    Args:\n        experiment_name (str): The name of the experiment.\n\n    Raises:\n        Exception: If a directory with the same name already exists.\n    \"\"\"\n    now = datetime.now()\n    now_string = now.strftime(\"%d-%m-%Y+%H_%M\")\n\n    self.act_experiment_path = self.base_path / f\"{experiment_name}_{now_string}\"\n\n    if os.path.exists(self.get_results_path()):\n        raise Exception(\n            \"Error, there is already a directory with results with the same name,\"\n            \"make sure no results will be overwritten\"  \n        )\n    else:\n        os.makedirs(self.get_results_path())\n    os.makedirs(self.get_tmp_path())\n</code></pre>"},{"location":"api/#ada_verona.ExperimentRepository.load_experiment","title":"<code>load_experiment(experiment_name)</code>","text":"<p>Load an existing experiment with the given name.</p> <p>Parameters:</p> Name Type Description Default <code>experiment_name</code> <code>str</code> <p>The name of the experiment.</p> required Source code in <code>ada_verona/database/experiment_repository.py</code> <pre><code>def load_experiment(self, experiment_name: str) -&gt; None:\n    \"\"\"\n    Load an existing experiment with the given name.\n\n    Args:\n        experiment_name (str): The name of the experiment.\n    \"\"\"\n    self.act_experiment_path = self.base_path / experiment_name\n</code></pre>"},{"location":"api/#ada_verona.ExperimentRepository.load_network_from_csv_row","title":"<code>load_network_from_csv_row(row)</code>","text":"<p>Load information from a single row and instantiate the Network via the abstract class. </p> <p>Returns:</p> Type Description <code>Network</code> <p>Loaded Network</p> Source code in <code>ada_verona/database/experiment_repository.py</code> <pre><code>def load_network_from_csv_row(self, row: pd.Series) -&gt; Network:\n    \"\"\"\n        Load information from a single row and instantiate the Network via the abstract class. \n\n        Returns:\n            Loaded Network\n    \"\"\"\n    architecture = row.get(\"architecture\", None)\n    if architecture is None or pd.isna(architecture) or str(architecture).strip() == \"\":\n        raise ValueError(\"All network types require 'architecture' field\")\n\n    arch = Path(architecture)\n    args = {\n        \"architecture\": arch,\n        \"network_type\": row[\"network_type\"],\n    }\n\n    if \"weights\" in row and pd.notna(row[\"weights\"]) and str(row[\"weights\"]).strip():\n        args[\"weights\"] = Path(row[\"weights\"])\n\n\n    return Network.from_file(args)\n</code></pre>"},{"location":"api/#ada_verona.ExperimentRepository.load_networks_from_csv","title":"<code>load_networks_from_csv(network_csv_path)</code>","text":"<p>Load networks from a CSV file.</p> <p>Parameters:</p> Name Type Description Default <code>network_csv_path</code> <code>str</code> <p>Path to the CSV file.</p> required <p>Returns:</p> Type Description <code>list[Network]</code> <p>List of Network objects to use for experiments.</p> Source code in <code>ada_verona/database/experiment_repository.py</code> <pre><code>def load_networks_from_csv(self, network_csv_path: str) -&gt; list[Network]:\n    \"\"\"\n    Load networks from a CSV file.\n\n    Args:\n        network_csv_path: Path to the CSV file.\n\n    Returns:\n        List of Network objects to use for experiments.\n    \"\"\"\n    try:\n        df = pd.read_csv(network_csv_path)\n    except (pd.errors.EmptyDataError, pd.errors.ParserError) as e:\n        msg = (\n            f\"Networks CSV file is empty: {network_csv_path}\"\n            if isinstance(e, pd.errors.EmptyDataError)\n            else f\"Error parsing networks CSV file: {e}\"\n        )\n        raise ValueError(msg) from None\n\n    missing = [c for c in [\"architecture\", \"network_type\"] if c not in df.columns]\n    if missing:\n        raise ValueError(f\"Missing required columns in networks CSV: {missing}\")\n\n    networks = []\n    for _, row in df.iterrows():\n        try:\n            networks.append(self.load_network_from_csv_row(row))\n        except Exception as e:\n            raise ValueError(\n                f\"Error creating network from row {row.to_dict()}: {e}\"\n            ) from e\n\n    return networks\n</code></pre>"},{"location":"api/#ada_verona.ExperimentRepository.load_verification_context_from_yaml","title":"<code>load_verification_context_from_yaml(file_path)</code>","text":"<p>Load the verification context from a YAML file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Path</code> <p>The path to the YAML file.</p> required <p>Returns:</p> Name Type Description <code>VerificationContext</code> <code>VerificationContext</code> <p>The loaded verification context.</p> Source code in <code>ada_verona/database/experiment_repository.py</code> <pre><code>def load_verification_context_from_yaml(self, file_path: Path) -&gt; VerificationContext:\n    \"\"\"\n    Load the verification context from a YAML file.\n\n    Args:\n        file_path (Path): The path to the YAML file.\n\n    Returns:\n        VerificationContext: The loaded verification context.\n    \"\"\"\n    with open(file_path) as file:\n        data = yaml.safe_load(file)\n        return VerificationContext.from_dict(data)\n</code></pre>"},{"location":"api/#ada_verona.ExperimentRepository.save_configuration","title":"<code>save_configuration(data)</code>","text":"<p>Save the configuration data to a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>The configuration data to save.</p> required Source code in <code>ada_verona/database/experiment_repository.py</code> <pre><code>def save_configuration(self, data: dict) -&gt; None:\n    \"\"\"\n    Save the configuration data to a JSON file.\n\n    Args:\n        data (dict): The configuration data to save.\n    \"\"\"\n    with open(self.get_act_experiment_path() / \"configuration.json\", \"w\") as outfile:\n        json.dump(data, outfile)\n</code></pre>"},{"location":"api/#ada_verona.ExperimentRepository.save_per_epsilon_result_df","title":"<code>save_per_epsilon_result_df()</code>","text":"<p>Save the per-epsilon result DataFrame to a CSV file.</p> Source code in <code>ada_verona/database/experiment_repository.py</code> <pre><code>def save_per_epsilon_result_df(self) -&gt; None:\n    \"\"\"\n    Save the per-epsilon result DataFrame to a CSV file.\n    \"\"\"\n    per_epsilon_result_df = self.get_per_epsilon_result_df()\n    per_epsilon_result_df.to_csv(self.get_results_path() / PER_EPSILON_RESULT_CSV_NAME)\n</code></pre>"},{"location":"api/#ada_verona.ExperimentRepository.save_plots","title":"<code>save_plots()</code>","text":"<p>Save the plots generated from the result DataFrame.</p> Source code in <code>ada_verona/database/experiment_repository.py</code> <pre><code>def save_plots(self) -&gt; None:\n    \"\"\"\n    Save the plots generated from the result DataFrame.\n    \"\"\"\n    df = self.get_result_df()\n    report_creator = ReportCreator(df)\n    hist_figure = report_creator.create_hist_figure()\n    hist_figure.savefig(self.get_results_path() / \"hist_figure.png\", bbox_inches=\"tight\")\n\n    boxplot = report_creator.create_box_figure()\n    boxplot.savefig(self.get_results_path() / \"boxplot.png\", bbox_inches=\"tight\")\n\n    kde_figure = report_creator.create_kde_figure()\n    kde_figure.savefig(self.get_results_path() / \"kde_plot.png\", bbox_inches=\"tight\")\n\n    ecdf_figure = report_creator.create_ecdf_figure()\n    ecdf_figure.savefig(self.get_results_path() / \"ecdf_plot.png\", bbox_inches=\"tight\")\n</code></pre>"},{"location":"api/#ada_verona.ExperimentRepository.save_result","title":"<code>save_result(result)</code>","text":"<p>Save a single epsilon value result to the CSV file.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>EpsilonValueResult</code> <p>The epsilon value result to save.</p> required Source code in <code>ada_verona/database/experiment_repository.py</code> <pre><code>def save_result(self, result: EpsilonValueResult) -&gt; None:\n    \"\"\"\n    Save a single epsilon value result to the CSV file.\n\n    Args:\n        result (EpsilonValueResult): The epsilon value result to save.\n    \"\"\"\n    result_df_path = self.get_results_path() / DEFAULT_RESULT_CSV_NAME\n    if result_df_path.exists():\n        df = pd.read_csv(result_df_path, index_col=0)\n        df.loc[len(df.index)] = result.to_dict()\n    else:\n        df = pd.DataFrame([result.to_dict()])\n    df.to_csv(result_df_path)\n</code></pre>"},{"location":"api/#ada_verona.ExperimentRepository.save_results","title":"<code>save_results(results)</code>","text":"<p>Save the list of epsilon value results to a CSV file.</p> <p>Parameters:</p> Name Type Description Default <code>results</code> <code>list[EpsilonValueResult]</code> <p>The list of epsilon value results to save.</p> required Source code in <code>ada_verona/database/experiment_repository.py</code> <pre><code>def save_results(self, results: list[EpsilonValueResult]) -&gt; None:\n    \"\"\"\n    Save the list of epsilon value results to a CSV file.\n\n    Args:\n        results (list[EpsilonValueResult]): The list of epsilon value results to save.\n    \"\"\"\n    result_df = pd.DataFrame([x.to_dict() for x in results])\n    result_df.to_csv(self.get_results_path() / DEFAULT_RESULT_CSV_NAME)\n</code></pre>"},{"location":"api/#ada_verona.ExperimentRepository.save_verification_context_to_yaml","title":"<code>save_verification_context_to_yaml(file_path, verification_context)</code>","text":"<p>Save the verification context to a YAML file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Path</code> <p>The path to save the YAML file.</p> required <code>verification_context</code> <code>VerificationContext</code> <p>The verification context to save.</p> required <p>Returns:</p> Name Type Description <code>Path</code> <code>Path</code> <p>The path to the saved YAML file.</p> Source code in <code>ada_verona/database/experiment_repository.py</code> <pre><code>def save_verification_context_to_yaml(self, file_path: Path, verification_context: VerificationContext) -&gt; Path:\n    \"\"\"\n    Save the verification context to a YAML file.\n\n    Args:\n        file_path (Path): The path to save the YAML file.\n        verification_context (VerificationContext): The verification context to save.\n\n    Returns:\n        Path: The path to the saved YAML file.\n    \"\"\"\n    with open(file_path, \"w\") as file:\n        yaml.dump(verification_context.to_dict(), file)\n    return file_path\n</code></pre>"},{"location":"api/#ada_verona.IterativeEpsilonValueEstimator","title":"<code>IterativeEpsilonValueEstimator</code>","text":"<p>               Bases: <code>EpsilonValueEstimator</code></p> <p>A class to estimate the epsilon value using an iterative search with configurable direction.</p> Source code in <code>ada_verona/epsilon_value_estimator/iterative_epsilon_value_estimator.py</code> <pre><code>class IterativeEpsilonValueEstimator(EpsilonValueEstimator):\n    \"\"\"\n    A class to estimate the epsilon value using an iterative search with configurable direction.\n    \"\"\"\n    def compute_epsilon_value(\n    self,\n    verification_context: VerificationContext,\n    reverse_search=False,\n) -&gt; EpsilonValueResult:\n        \"\"\"\n        Compute the epsilon value using an iterative search.\n\n        Args:\n            verification_context (VerificationContext): The context for verification.\n\n        Returns:\n            EpsilonValueResult: The result of the epsilon value estimation.\n        \"\"\"\n        sorted_epsilons = sorted(self.epsilon_value_list, reverse=reverse_search)\n        epsilon_status_list = [EpsilonStatus(x, None, None, self.verifier.name) for x in sorted_epsilons]\n        start_time = time.time()\n        highest_unsat_value, lowest_sat_value, epsilon_status_list = self.iterative_search(\n            verification_context, epsilon_status_list\n        )\n        duration = time.time() - start_time\n        epsilon_value_result = EpsilonValueResult(verification_context, \n                                                  highest_unsat_value, \n                                                  lowest_sat_value, \n                                                  duration, \n                                                  self.verifier.name)\n\n        return epsilon_value_result\n\n    def iterative_search(self, \n                         verification_context: VerificationContext, \n                        epsilon_status_list: list[EpsilonStatus]) -&gt; tuple[float, float, list]:\n        \"\"\"\n        Perform search and determine results based on actual epsilon values. \n        Find the highest UNSAT and smallest SAT epsilon values.\n\n        Args:\n            verification_context (VerificationContext): The context for verification.\n            epsilon_status_list (list[EpsilonStatus]): The list of epsilon statuses.\n\n        Returns:\n            float: The highest UNSAT epsilon value.\n            float: The smallest SAT epsilon value.\n            list: The epsilon status list.\n        \"\"\"\n\n        for status in epsilon_status_list:\n            outcome = self.verifier.verify(verification_context, status.value)\n            status.result = outcome.result\n            status.time = outcome.took\n            verification_context.save_result(status)\n            logger.info(f\"epsilon value: {status.value}, result: {status.result}\")\n\n        unsat_values = [x.value for x in epsilon_status_list if x.result == VerificationResult.UNSAT]\n        sat_values = [x.value for x in epsilon_status_list if x.result == VerificationResult.SAT]\n\n        highest_unsat = max(unsat_values) if unsat_values else 0\n        lowest_sat = min(sat_values) if sat_values else 'undefined'\n\n\n        return highest_unsat, lowest_sat, epsilon_status_list\n</code></pre>"},{"location":"api/#ada_verona.IterativeEpsilonValueEstimator.compute_epsilon_value","title":"<code>compute_epsilon_value(verification_context, reverse_search=False)</code>","text":"<p>Compute the epsilon value using an iterative search.</p> <p>Parameters:</p> Name Type Description Default <code>verification_context</code> <code>VerificationContext</code> <p>The context for verification.</p> required <p>Returns:</p> Name Type Description <code>EpsilonValueResult</code> <code>EpsilonValueResult</code> <p>The result of the epsilon value estimation.</p> Source code in <code>ada_verona/epsilon_value_estimator/iterative_epsilon_value_estimator.py</code> <pre><code>    def compute_epsilon_value(\n    self,\n    verification_context: VerificationContext,\n    reverse_search=False,\n) -&gt; EpsilonValueResult:\n        \"\"\"\n        Compute the epsilon value using an iterative search.\n\n        Args:\n            verification_context (VerificationContext): The context for verification.\n\n        Returns:\n            EpsilonValueResult: The result of the epsilon value estimation.\n        \"\"\"\n        sorted_epsilons = sorted(self.epsilon_value_list, reverse=reverse_search)\n        epsilon_status_list = [EpsilonStatus(x, None, None, self.verifier.name) for x in sorted_epsilons]\n        start_time = time.time()\n        highest_unsat_value, lowest_sat_value, epsilon_status_list = self.iterative_search(\n            verification_context, epsilon_status_list\n        )\n        duration = time.time() - start_time\n        epsilon_value_result = EpsilonValueResult(verification_context, \n                                                  highest_unsat_value, \n                                                  lowest_sat_value, \n                                                  duration, \n                                                  self.verifier.name)\n\n        return epsilon_value_result\n</code></pre>"},{"location":"api/#ada_verona.IterativeEpsilonValueEstimator.iterative_search","title":"<code>iterative_search(verification_context, epsilon_status_list)</code>","text":"<p>Perform search and determine results based on actual epsilon values.  Find the highest UNSAT and smallest SAT epsilon values.</p> <p>Parameters:</p> Name Type Description Default <code>verification_context</code> <code>VerificationContext</code> <p>The context for verification.</p> required <code>epsilon_status_list</code> <code>list[EpsilonStatus]</code> <p>The list of epsilon statuses.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The highest UNSAT epsilon value.</p> <code>float</code> <code>float</code> <p>The smallest SAT epsilon value.</p> <code>list</code> <code>list</code> <p>The epsilon status list.</p> Source code in <code>ada_verona/epsilon_value_estimator/iterative_epsilon_value_estimator.py</code> <pre><code>def iterative_search(self, \n                     verification_context: VerificationContext, \n                    epsilon_status_list: list[EpsilonStatus]) -&gt; tuple[float, float, list]:\n    \"\"\"\n    Perform search and determine results based on actual epsilon values. \n    Find the highest UNSAT and smallest SAT epsilon values.\n\n    Args:\n        verification_context (VerificationContext): The context for verification.\n        epsilon_status_list (list[EpsilonStatus]): The list of epsilon statuses.\n\n    Returns:\n        float: The highest UNSAT epsilon value.\n        float: The smallest SAT epsilon value.\n        list: The epsilon status list.\n    \"\"\"\n\n    for status in epsilon_status_list:\n        outcome = self.verifier.verify(verification_context, status.value)\n        status.result = outcome.result\n        status.time = outcome.took\n        verification_context.save_result(status)\n        logger.info(f\"epsilon value: {status.value}, result: {status.result}\")\n\n    unsat_values = [x.value for x in epsilon_status_list if x.result == VerificationResult.UNSAT]\n    sat_values = [x.value for x in epsilon_status_list if x.result == VerificationResult.SAT]\n\n    highest_unsat = max(unsat_values) if unsat_values else 0\n    lowest_sat = min(sat_values) if sat_values else 'undefined'\n\n\n    return highest_unsat, lowest_sat, epsilon_status_list\n</code></pre>"},{"location":"api/#ada_verona.Network","title":"<code>Network</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for networks that can be either ONNX or PyTorch.</p> <p>This class provides a common interface for both network types.</p> Source code in <code>ada_verona/database/machine_learning_model/network.py</code> <pre><code>class Network(ABC):\n    \"\"\"\n    Abstract base class for networks that can be either ONNX or PyTorch.\n\n    This class provides a common interface for both network types.\n    \"\"\"\n\n    @abstractmethod\n    def load_pytorch_model(self) -&gt; torch.nn.Module:\n        \"\"\"\n        Load the PyTorch model.\n\n        Returns:\n            torch.nn.Module: The loaded PyTorch model.\n        \"\"\"\n        raise NotImplementedError(\"This is an abstract method and should be implemented in subclasses.\")\n\n\n\n    @abstractmethod\n    def get_input_shape(self) -&gt; np.ndarray | tuple[int, ...]:\n        \"\"\"\n        Get the input shape of the model.\n\n        Returns:\n            Union[np.ndarray, tuple[int, ...]]: The input shape of the model.\n        \"\"\"\n        raise NotImplementedError(\"This is an abstract method and should be implemented in subclasses.\")\n\n\n\n    @abstractmethod\n    def to_dict(self) -&gt; dict:\n        \"\"\"\n        Convert the network to a dictionary.\n\n        Returns:\n            dict: The dictionary representation of the network.\n        \"\"\"\n        raise NotImplementedError(\"This is an abstract method and should be implemented in subclasses.\")\n\n\n\n    @classmethod\n    @abstractmethod\n    def from_dict(cls, data: dict) -&gt; \"Network\":\n        \"\"\"\n        Create a network from a dictionary.\n\n        Args:\n            data (dict): The dictionary containing the network attributes.\n\n        Returns:\n            BaseNetwork: The created network.\n        \"\"\"\n        class_name = data.pop(\"type\", None)\n        module_name = data.pop(\"module\", None)  # Get module info\n        if not class_name or not module_name:\n            raise ValueError(\"Missing 'class' or 'module' key in dictionary\")\n        try:\n            module = importlib.import_module(module_name)  # Dynamically import module\n            subclass = getattr(module, class_name)  # Get class from module\n        except (ModuleNotFoundError, AttributeError) as e:\n            raise ValueError(f\"Could not import {class_name} from {module_name}: {e}\") from e\n\n        return subclass.from_dict(data)  # Call subclass's `from_dict`\n\n\n    @property\n    @abstractmethod\n    def name(self) -&gt; str:\n        \"\"\"\n        Get the name of the network.\n\n        Returns:\n            str: The name of the network.\n        \"\"\"\n        raise NotImplementedError(\"This is an abstract method and should be implemented in subclasses.\")\n\n\n\n\n    @classmethod\n    def from_file(cls, file:dict[Path]):\n        \"\"\"Create network from file\n        Args: \n            file (dict[Path]): contains the paths to the relevant weights (for ONNX) \n            and additionally to the architecture file for PyTorch networks.\n\n        Returns: \n            Created network from the correct class OR error. \n        \"\"\"\n        if file.get('network_type') == \"onnx\":\n            module = importlib.import_module(\"ada_verona.database.machine_learning_model.onnx_network\")\n            subclass = module.ONNXNetwork  \n            return subclass.from_file(file.get('architecture'))\n        elif file.get('network_type')== \"pytorch\":\n            module = importlib.import_module(\n                \"ada_verona.database.machine_learning_model.pytorch_network\") \n            subclass = module.PyTorchNetwork\n            return subclass.from_file(file.get('architecture'), file.get('weights'))\n        else:\n            raise NotImplementedError(\n                f\"Only .onnx and pytorch files are supported at the moment, got: {file.get('network_type')}\")\n</code></pre>"},{"location":"api/#ada_verona.Network.name","title":"<code>name</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the name of the network.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The name of the network.</p>"},{"location":"api/#ada_verona.Network.from_dict","title":"<code>from_dict(data)</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"<p>Create a network from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>The dictionary containing the network attributes.</p> required <p>Returns:</p> Name Type Description <code>BaseNetwork</code> <code>Network</code> <p>The created network.</p> Source code in <code>ada_verona/database/machine_learning_model/network.py</code> <pre><code>@classmethod\n@abstractmethod\ndef from_dict(cls, data: dict) -&gt; \"Network\":\n    \"\"\"\n    Create a network from a dictionary.\n\n    Args:\n        data (dict): The dictionary containing the network attributes.\n\n    Returns:\n        BaseNetwork: The created network.\n    \"\"\"\n    class_name = data.pop(\"type\", None)\n    module_name = data.pop(\"module\", None)  # Get module info\n    if not class_name or not module_name:\n        raise ValueError(\"Missing 'class' or 'module' key in dictionary\")\n    try:\n        module = importlib.import_module(module_name)  # Dynamically import module\n        subclass = getattr(module, class_name)  # Get class from module\n    except (ModuleNotFoundError, AttributeError) as e:\n        raise ValueError(f\"Could not import {class_name} from {module_name}: {e}\") from e\n\n    return subclass.from_dict(data)  # Call subclass's `from_dict`\n</code></pre>"},{"location":"api/#ada_verona.Network.from_file","title":"<code>from_file(file)</code>  <code>classmethod</code>","text":"<p>Create network from file Args:      file (dict[Path]): contains the paths to the relevant weights (for ONNX)      and additionally to the architecture file for PyTorch networks.</p> <p>Returns:</p> Type Description <p>Created network from the correct class OR error.</p> Source code in <code>ada_verona/database/machine_learning_model/network.py</code> <pre><code>@classmethod\ndef from_file(cls, file:dict[Path]):\n    \"\"\"Create network from file\n    Args: \n        file (dict[Path]): contains the paths to the relevant weights (for ONNX) \n        and additionally to the architecture file for PyTorch networks.\n\n    Returns: \n        Created network from the correct class OR error. \n    \"\"\"\n    if file.get('network_type') == \"onnx\":\n        module = importlib.import_module(\"ada_verona.database.machine_learning_model.onnx_network\")\n        subclass = module.ONNXNetwork  \n        return subclass.from_file(file.get('architecture'))\n    elif file.get('network_type')== \"pytorch\":\n        module = importlib.import_module(\n            \"ada_verona.database.machine_learning_model.pytorch_network\") \n        subclass = module.PyTorchNetwork\n        return subclass.from_file(file.get('architecture'), file.get('weights'))\n    else:\n        raise NotImplementedError(\n            f\"Only .onnx and pytorch files are supported at the moment, got: {file.get('network_type')}\")\n</code></pre>"},{"location":"api/#ada_verona.Network.get_input_shape","title":"<code>get_input_shape()</code>  <code>abstractmethod</code>","text":"<p>Get the input shape of the model.</p> <p>Returns:</p> Type Description <code>ndarray | tuple[int, ...]</code> <p>Union[np.ndarray, tuple[int, ...]]: The input shape of the model.</p> Source code in <code>ada_verona/database/machine_learning_model/network.py</code> <pre><code>@abstractmethod\ndef get_input_shape(self) -&gt; np.ndarray | tuple[int, ...]:\n    \"\"\"\n    Get the input shape of the model.\n\n    Returns:\n        Union[np.ndarray, tuple[int, ...]]: The input shape of the model.\n    \"\"\"\n    raise NotImplementedError(\"This is an abstract method and should be implemented in subclasses.\")\n</code></pre>"},{"location":"api/#ada_verona.Network.load_pytorch_model","title":"<code>load_pytorch_model()</code>  <code>abstractmethod</code>","text":"<p>Load the PyTorch model.</p> <p>Returns:</p> Type Description <code>Module</code> <p>torch.nn.Module: The loaded PyTorch model.</p> Source code in <code>ada_verona/database/machine_learning_model/network.py</code> <pre><code>@abstractmethod\ndef load_pytorch_model(self) -&gt; torch.nn.Module:\n    \"\"\"\n    Load the PyTorch model.\n\n    Returns:\n        torch.nn.Module: The loaded PyTorch model.\n    \"\"\"\n    raise NotImplementedError(\"This is an abstract method and should be implemented in subclasses.\")\n</code></pre>"},{"location":"api/#ada_verona.Network.to_dict","title":"<code>to_dict()</code>  <code>abstractmethod</code>","text":"<p>Convert the network to a dictionary.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The dictionary representation of the network.</p> Source code in <code>ada_verona/database/machine_learning_model/network.py</code> <pre><code>@abstractmethod\ndef to_dict(self) -&gt; dict:\n    \"\"\"\n    Convert the network to a dictionary.\n\n    Returns:\n        dict: The dictionary representation of the network.\n    \"\"\"\n    raise NotImplementedError(\"This is an abstract method and should be implemented in subclasses.\")\n</code></pre>"},{"location":"api/#ada_verona.ONNXNetwork","title":"<code>ONNXNetwork</code>","text":"<p>               Bases: <code>Network</code></p> <p>Data class representing an ONNX network with its path.</p> <p>Attributes:</p> Name Type Description <code>path</code> <code>Path</code> <p>The path to the network file.</p> <code>onnx_model</code> <code>ModelProto</code> <p>The loaded ONNX model. Defaults to None.</p> <code>torch_model_wrapper</code> <code>TorchModelWrapper</code> <p>The PyTorch model wrapper. Defaults to None.</p> Source code in <code>ada_verona/database/machine_learning_model/onnx_network.py</code> <pre><code>class ONNXNetwork(Network):\n    \"\"\"\n    Data class representing an ONNX network with its path.\n\n    Attributes:\n        path (Path): The path to the network file.\n        onnx_model (onnx.ModelProto, optional): The loaded ONNX model. Defaults to None.\n        torch_model_wrapper (TorchModelWrapper, optional): The PyTorch model wrapper. Defaults to None.\n    \"\"\"\n\n    def __init__(self, path: Path) -&gt; None:\n        \"\"\"\n        Initialize the Network with the given path.\n\n        Args:\n            path (Path): The path to the network file.\n        \"\"\"\n        self.path = path\n        self.onnx_model = None\n        self.torch_model_wrapper = None\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"\n        Get the name of the network.\n\n        Returns:\n            str: The name of the network.\n        \"\"\"\n        return self.path.stem\n\n    def load_onnx_model(self) -&gt; onnx.ModelProto:\n        \"\"\"\n        Load the ONNX model from the network path.\n\n        Returns:\n            onnx.ModelProto: The loaded ONNX model.\n        \"\"\"\n        model = self.onnx_model\n        if model is None:\n            model = onnx.load(str(self.path))\n            self.onnx_model = model\n\n        return model\n\n    def get_input_shape(self) -&gt; np.ndarray:\n        \"\"\"\n        Get the input shape of the ONNX model.\n\n        Returns:\n            np.ndarray: The input shape of the ONNX model.\n        \"\"\"\n        model = self.load_onnx_model()\n        input_shape = tuple([d.dim_value for d in model.graph.input[0].type.tensor_type.shape.dim])\n        input_shape = [x if x != 0 else -1 for x in input_shape]\n\n        return input_shape\n\n    def load_pytorch_model(self) -&gt; torch.nn.Module:\n        \"\"\"\n        Load the PyTorch model from the ONNX model.\n\n        Returns:\n            torch.nn.Module: The loaded PyTorch model.\n        \"\"\"\n        device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n        torch_model_wrapper = self.torch_model_wrapper\n        if torch_model_wrapper is None:\n            torch_model = convert(self.path).to(device)\n            torch_model_wrapper = TorchModelWrapper(torch_model, self.get_input_shape())\n            self.torch_model_wrapper = torch_model_wrapper\n\n        return torch_model_wrapper\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"\n        Convert the Network to a dictionary.\n\n        Returns:\n            dict: The dictionary representation of the Network.\n        \"\"\"\n\n        return dict(network_path =  str(self.path), \n                type=self.__class__.__name__,\n                module=self.__class__.__module__,\n                    )\n\n    @classmethod\n    def from_dict(cls, data: dict)-&gt; \"ONNXNetwork\":\n        \"\"\"\n        Create a Network from a dictionary.\n\n        Args:\n            data (dict): The dictionary containing the Network attributes.\n\n        Returns:\n            Network: The created Network.\n        \"\"\"\n        return cls(path = data['network_path'])\n\n    @classmethod\n    def from_file(cls, file:Path)-&gt; \"ONNXNetwork\":\n        \"\"\"\n        Create a ONNXNetwork from a dictionary.\n\n        Args:\n            file (Path): Path at which the network is stored. \n\n        Returns:\n            ONNXNetwork: The created ONNXNetwork.\n        \"\"\"\n\n        if not file.is_file():\n            raise FileNotFoundError(f\"File not found: {file}\")\n\n        return cls(path = file)\n</code></pre>"},{"location":"api/#ada_verona.ONNXNetwork.name","title":"<code>name</code>  <code>property</code>","text":"<p>Get the name of the network.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The name of the network.</p>"},{"location":"api/#ada_verona.ONNXNetwork.__init__","title":"<code>__init__(path)</code>","text":"<p>Initialize the Network with the given path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>The path to the network file.</p> required Source code in <code>ada_verona/database/machine_learning_model/onnx_network.py</code> <pre><code>def __init__(self, path: Path) -&gt; None:\n    \"\"\"\n    Initialize the Network with the given path.\n\n    Args:\n        path (Path): The path to the network file.\n    \"\"\"\n    self.path = path\n    self.onnx_model = None\n    self.torch_model_wrapper = None\n</code></pre>"},{"location":"api/#ada_verona.ONNXNetwork.from_dict","title":"<code>from_dict(data)</code>  <code>classmethod</code>","text":"<p>Create a Network from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>The dictionary containing the Network attributes.</p> required <p>Returns:</p> Name Type Description <code>Network</code> <code>ONNXNetwork</code> <p>The created Network.</p> Source code in <code>ada_verona/database/machine_learning_model/onnx_network.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: dict)-&gt; \"ONNXNetwork\":\n    \"\"\"\n    Create a Network from a dictionary.\n\n    Args:\n        data (dict): The dictionary containing the Network attributes.\n\n    Returns:\n        Network: The created Network.\n    \"\"\"\n    return cls(path = data['network_path'])\n</code></pre>"},{"location":"api/#ada_verona.ONNXNetwork.from_file","title":"<code>from_file(file)</code>  <code>classmethod</code>","text":"<p>Create a ONNXNetwork from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>Path</code> <p>Path at which the network is stored. </p> required <p>Returns:</p> Name Type Description <code>ONNXNetwork</code> <code>ONNXNetwork</code> <p>The created ONNXNetwork.</p> Source code in <code>ada_verona/database/machine_learning_model/onnx_network.py</code> <pre><code>@classmethod\ndef from_file(cls, file:Path)-&gt; \"ONNXNetwork\":\n    \"\"\"\n    Create a ONNXNetwork from a dictionary.\n\n    Args:\n        file (Path): Path at which the network is stored. \n\n    Returns:\n        ONNXNetwork: The created ONNXNetwork.\n    \"\"\"\n\n    if not file.is_file():\n        raise FileNotFoundError(f\"File not found: {file}\")\n\n    return cls(path = file)\n</code></pre>"},{"location":"api/#ada_verona.ONNXNetwork.get_input_shape","title":"<code>get_input_shape()</code>","text":"<p>Get the input shape of the ONNX model.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The input shape of the ONNX model.</p> Source code in <code>ada_verona/database/machine_learning_model/onnx_network.py</code> <pre><code>def get_input_shape(self) -&gt; np.ndarray:\n    \"\"\"\n    Get the input shape of the ONNX model.\n\n    Returns:\n        np.ndarray: The input shape of the ONNX model.\n    \"\"\"\n    model = self.load_onnx_model()\n    input_shape = tuple([d.dim_value for d in model.graph.input[0].type.tensor_type.shape.dim])\n    input_shape = [x if x != 0 else -1 for x in input_shape]\n\n    return input_shape\n</code></pre>"},{"location":"api/#ada_verona.ONNXNetwork.load_onnx_model","title":"<code>load_onnx_model()</code>","text":"<p>Load the ONNX model from the network path.</p> <p>Returns:</p> Type Description <code>ModelProto</code> <p>onnx.ModelProto: The loaded ONNX model.</p> Source code in <code>ada_verona/database/machine_learning_model/onnx_network.py</code> <pre><code>def load_onnx_model(self) -&gt; onnx.ModelProto:\n    \"\"\"\n    Load the ONNX model from the network path.\n\n    Returns:\n        onnx.ModelProto: The loaded ONNX model.\n    \"\"\"\n    model = self.onnx_model\n    if model is None:\n        model = onnx.load(str(self.path))\n        self.onnx_model = model\n\n    return model\n</code></pre>"},{"location":"api/#ada_verona.ONNXNetwork.load_pytorch_model","title":"<code>load_pytorch_model()</code>","text":"<p>Load the PyTorch model from the ONNX model.</p> <p>Returns:</p> Type Description <code>Module</code> <p>torch.nn.Module: The loaded PyTorch model.</p> Source code in <code>ada_verona/database/machine_learning_model/onnx_network.py</code> <pre><code>def load_pytorch_model(self) -&gt; torch.nn.Module:\n    \"\"\"\n    Load the PyTorch model from the ONNX model.\n\n    Returns:\n        torch.nn.Module: The loaded PyTorch model.\n    \"\"\"\n    device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n    torch_model_wrapper = self.torch_model_wrapper\n    if torch_model_wrapper is None:\n        torch_model = convert(self.path).to(device)\n        torch_model_wrapper = TorchModelWrapper(torch_model, self.get_input_shape())\n        self.torch_model_wrapper = torch_model_wrapper\n\n    return torch_model_wrapper\n</code></pre>"},{"location":"api/#ada_verona.ONNXNetwork.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert the Network to a dictionary.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The dictionary representation of the Network.</p> Source code in <code>ada_verona/database/machine_learning_model/onnx_network.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"\n    Convert the Network to a dictionary.\n\n    Returns:\n        dict: The dictionary representation of the Network.\n    \"\"\"\n\n    return dict(network_path =  str(self.path), \n            type=self.__class__.__name__,\n            module=self.__class__.__module__,\n                )\n</code></pre>"},{"location":"api/#ada_verona.PyTorchNetwork","title":"<code>PyTorchNetwork</code>","text":"<p>               Bases: <code>Network</code></p> <p>A class representing a PyTorch network with architecture and weights files.</p> <p>Attributes:</p> Name Type Description <code>architecture_path</code> <code>Path</code> <p>Path to the .py file containing the model architecture.</p> <code>weights</code> <code>Path</code> <p>Path to the .pt/.pth file containing the model weights.</p> <code>model</code> <code>Module</code> <p>The loaded PyTorch model. Defaults to None.</p> <code>torch_model_wrapper</code> <code>TorchModelWrapper</code> <p>The PyTorch model wrapper. Defaults to None.</p> Source code in <code>ada_verona/database/machine_learning_model/pytorch_network.py</code> <pre><code>class PyTorchNetwork(Network):\n    \"\"\"\n    A class representing a PyTorch network with architecture and weights files.\n\n    Attributes:\n        architecture_path (Path): Path to the .py file containing the model architecture.\n        weights (Path): Path to the .pt/.pth file containing the model weights.\n        model (torch.nn.Module, optional): The loaded PyTorch model. Defaults to None.\n        torch_model_wrapper (TorchModelWrapper, optional): The PyTorch model wrapper. Defaults to None.\n    \"\"\"\n\n    def __init__(self, architecture: Path, weights: Path) -&gt; None:\n        \"\"\"\n        Initialize the PyTorchNetwork with architecture and weights paths.\n\n        Args:\n            architecture_path (Path): Path to the .py file containing the model architecture.\n            weights (Path): Path to the .pt/.pth file containing the model weights.\n        \"\"\"\n        self.architecture = architecture\n        self.weights = weights\n        self.model = None\n        self.torch_model_wrapper = None\n        self.input_shape = None\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"\n        Get the name of the network.\n\n        Returns:\n            str: The name of the network.\n        \"\"\"\n        return self.weights.stem\n\n\n\n    def _find_model(self,mod) -&gt; torch.nn.Module | None:\n        # Directly defined model instance\n        model_instance = next(\n            (getattr(mod, name) for name in dir(mod)\n            if isinstance(getattr(mod, name), torch.nn.Module)),\n            None\n        )\n        if model_instance:\n            return model_instance\n\n        # Callable that returns a model\n        for name in dir(mod):\n            if name.startswith(\"_\"):\n                continue\n            attr = getattr(mod, name)\n            if callable(attr):\n                try:\n                    candidate = attr()\n                    if isinstance(candidate, torch.nn.Module):\n                        return candidate\n                except Exception:\n                    continue\n        return None\n\n    def load_model(self) -&gt; torch.nn.Module:\n        \"\"\"\n        Load the PyTorch model from the architecture and weights files.\n\n        Returns:\n            torch.nn.Module: The loaded PyTorch model.\n        \"\"\"\n\n        if self.model is not None:\n            return self.model\n\n        spec = importlib.util.spec_from_file_location(\"torch.nn.module\", self.architecture)\n        if not spec or not spec.loader:\n            raise ImportError(f\"Could not load model architecture from {self.architecture}\")\n\n        module = importlib.util.module_from_spec(spec)\n        spec.loader.exec_module(module)\n\n        model = self._find_model(module)\n        if model is None:\n            raise ValueError(f\"No PyTorch model found in {self.architecture}\")\n\n        if self.weights and self.weights.exists():\n            checkpoint = torch.load(self.weights, map_location=\"cpu\")\n\n            if isinstance(checkpoint, dict) and \"state_dict\" in checkpoint:\n                state_dict = checkpoint[\"state_dict\"]\n            else:\n                state_dict = checkpoint\n\n            model.load_state_dict(state_dict, strict=False) \n\n        self.model = model\n        return self.model\n\n    def get_input_shape(self) -&gt; np.ndarray:\n        \"\"\"\n        Get the input shape of the PyTorch model.\n        This is a placeholder - PyTorch models don't have fixed input shapes like ONNX models.\n\n        Returns:\n            np.ndarray: the input_shape\n        \"\"\"\n\n        if self.input_shape is None:\n            if self.model is None:\n                self.load_model()\n\n            # load the same module you already import for the model\n            spec = importlib.util.spec_from_file_location(\"model_module\", self.architecture)\n            module = importlib.util.module_from_spec(spec)\n            spec.loader.exec_module(module)\n\n            # look for a conventionally named attribute or function\n            if hasattr(module, \"EXPECTED_INPUT_SHAPE\"):\n                self.input_shape = np.array(module.EXPECTED_INPUT_SHAPE, dtype=int)\n            elif hasattr(module, \"get_input_shape\"):\n                self.input_shape = np.array(module.get_input_shape(), dtype=int)\n            else:\n                raise RuntimeError(\n                    \"Model architecture does not expose an input shape. \"\n                    \"Add an EXPECTED_INPUT_SHAPE variable or get_input_shape() function to the architecture file.\"\n                )\n\n        return self.input_shape\n\n    def load_pytorch_model(self) -&gt; torch.nn.Module:\n        \"\"\"\n        Load the PyTorch model and wrap it in a TorchModelWrapper.\n\n        Returns:\n            torch.nn.Module: The wrapped PyTorch model.\n        \"\"\"\n        if self.torch_model_wrapper is None:\n            model = self.load_model()\n            device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n            model = model.to(device)\n            model.eval()\n\n            self.torch_model_wrapper = TorchModelWrapper(model, self.get_input_shape())\n\n        return self.torch_model_wrapper\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"\n        Convert the PyTorchNetwork to a dictionary.\n\n        Returns:\n            dict: The dictionary representation of the PyTorchNetwork.\n        \"\"\"\n        return dict(\n            architecture=str(self.architecture),\n            weights=str(self.weights),\n            type=self.__class__.__name__,\n            module=self.__class__.__module__,\n        )\n\n    @classmethod\n    def from_dict(cls, data: dict) -&gt; \"PyTorchNetwork\":\n        \"\"\"\n        Create a PyTorchNetwork from a dictionary.\n\n        Args:\n            data (dict): The dictionary containing the PyTorchNetwork attributes.\n\n        Returns:\n            PyTorchNetwork: The created PyTorchNetwork.\n        \"\"\"\n        return cls(\n            architecture=Path(data[\"architecture\"]),\n            weights=Path(data[\"weights\"])\n        )\n\n    @classmethod\n    def from_file(cls, architecture:Path, weights:Path)-&gt; \"PyTorchNetwork\":\n        \"\"\"\n        Create a PyTorchNetwork from a dictionary.\n\n        Args:\n            file (Path): Path at which the network is stored. \n\n        Returns:\n            PyTorchNetwork: The created ONNXNetwork.\n        \"\"\"\n\n        for path, label in [(architecture, \"architecture\"), (weights, \"weights\")]:\n            if not path.is_file():\n                raise FileNotFoundError(f\"{label.capitalize()} file not found: {path}\")\n\n\n        return cls(architecture=architecture, weights=weights)\n</code></pre>"},{"location":"api/#ada_verona.PyTorchNetwork.name","title":"<code>name</code>  <code>property</code>","text":"<p>Get the name of the network.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The name of the network.</p>"},{"location":"api/#ada_verona.PyTorchNetwork.__init__","title":"<code>__init__(architecture, weights)</code>","text":"<p>Initialize the PyTorchNetwork with architecture and weights paths.</p> <p>Parameters:</p> Name Type Description Default <code>architecture_path</code> <code>Path</code> <p>Path to the .py file containing the model architecture.</p> required <code>weights</code> <code>Path</code> <p>Path to the .pt/.pth file containing the model weights.</p> required Source code in <code>ada_verona/database/machine_learning_model/pytorch_network.py</code> <pre><code>def __init__(self, architecture: Path, weights: Path) -&gt; None:\n    \"\"\"\n    Initialize the PyTorchNetwork with architecture and weights paths.\n\n    Args:\n        architecture_path (Path): Path to the .py file containing the model architecture.\n        weights (Path): Path to the .pt/.pth file containing the model weights.\n    \"\"\"\n    self.architecture = architecture\n    self.weights = weights\n    self.model = None\n    self.torch_model_wrapper = None\n    self.input_shape = None\n</code></pre>"},{"location":"api/#ada_verona.PyTorchNetwork.from_dict","title":"<code>from_dict(data)</code>  <code>classmethod</code>","text":"<p>Create a PyTorchNetwork from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>The dictionary containing the PyTorchNetwork attributes.</p> required <p>Returns:</p> Name Type Description <code>PyTorchNetwork</code> <code>PyTorchNetwork</code> <p>The created PyTorchNetwork.</p> Source code in <code>ada_verona/database/machine_learning_model/pytorch_network.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: dict) -&gt; \"PyTorchNetwork\":\n    \"\"\"\n    Create a PyTorchNetwork from a dictionary.\n\n    Args:\n        data (dict): The dictionary containing the PyTorchNetwork attributes.\n\n    Returns:\n        PyTorchNetwork: The created PyTorchNetwork.\n    \"\"\"\n    return cls(\n        architecture=Path(data[\"architecture\"]),\n        weights=Path(data[\"weights\"])\n    )\n</code></pre>"},{"location":"api/#ada_verona.PyTorchNetwork.from_file","title":"<code>from_file(architecture, weights)</code>  <code>classmethod</code>","text":"<p>Create a PyTorchNetwork from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>Path</code> <p>Path at which the network is stored. </p> required <p>Returns:</p> Name Type Description <code>PyTorchNetwork</code> <code>PyTorchNetwork</code> <p>The created ONNXNetwork.</p> Source code in <code>ada_verona/database/machine_learning_model/pytorch_network.py</code> <pre><code>@classmethod\ndef from_file(cls, architecture:Path, weights:Path)-&gt; \"PyTorchNetwork\":\n    \"\"\"\n    Create a PyTorchNetwork from a dictionary.\n\n    Args:\n        file (Path): Path at which the network is stored. \n\n    Returns:\n        PyTorchNetwork: The created ONNXNetwork.\n    \"\"\"\n\n    for path, label in [(architecture, \"architecture\"), (weights, \"weights\")]:\n        if not path.is_file():\n            raise FileNotFoundError(f\"{label.capitalize()} file not found: {path}\")\n\n\n    return cls(architecture=architecture, weights=weights)\n</code></pre>"},{"location":"api/#ada_verona.PyTorchNetwork.get_input_shape","title":"<code>get_input_shape()</code>","text":"<p>Get the input shape of the PyTorch model. This is a placeholder - PyTorch models don't have fixed input shapes like ONNX models.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: the input_shape</p> Source code in <code>ada_verona/database/machine_learning_model/pytorch_network.py</code> <pre><code>def get_input_shape(self) -&gt; np.ndarray:\n    \"\"\"\n    Get the input shape of the PyTorch model.\n    This is a placeholder - PyTorch models don't have fixed input shapes like ONNX models.\n\n    Returns:\n        np.ndarray: the input_shape\n    \"\"\"\n\n    if self.input_shape is None:\n        if self.model is None:\n            self.load_model()\n\n        # load the same module you already import for the model\n        spec = importlib.util.spec_from_file_location(\"model_module\", self.architecture)\n        module = importlib.util.module_from_spec(spec)\n        spec.loader.exec_module(module)\n\n        # look for a conventionally named attribute or function\n        if hasattr(module, \"EXPECTED_INPUT_SHAPE\"):\n            self.input_shape = np.array(module.EXPECTED_INPUT_SHAPE, dtype=int)\n        elif hasattr(module, \"get_input_shape\"):\n            self.input_shape = np.array(module.get_input_shape(), dtype=int)\n        else:\n            raise RuntimeError(\n                \"Model architecture does not expose an input shape. \"\n                \"Add an EXPECTED_INPUT_SHAPE variable or get_input_shape() function to the architecture file.\"\n            )\n\n    return self.input_shape\n</code></pre>"},{"location":"api/#ada_verona.PyTorchNetwork.load_model","title":"<code>load_model()</code>","text":"<p>Load the PyTorch model from the architecture and weights files.</p> <p>Returns:</p> Type Description <code>Module</code> <p>torch.nn.Module: The loaded PyTorch model.</p> Source code in <code>ada_verona/database/machine_learning_model/pytorch_network.py</code> <pre><code>def load_model(self) -&gt; torch.nn.Module:\n    \"\"\"\n    Load the PyTorch model from the architecture and weights files.\n\n    Returns:\n        torch.nn.Module: The loaded PyTorch model.\n    \"\"\"\n\n    if self.model is not None:\n        return self.model\n\n    spec = importlib.util.spec_from_file_location(\"torch.nn.module\", self.architecture)\n    if not spec or not spec.loader:\n        raise ImportError(f\"Could not load model architecture from {self.architecture}\")\n\n    module = importlib.util.module_from_spec(spec)\n    spec.loader.exec_module(module)\n\n    model = self._find_model(module)\n    if model is None:\n        raise ValueError(f\"No PyTorch model found in {self.architecture}\")\n\n    if self.weights and self.weights.exists():\n        checkpoint = torch.load(self.weights, map_location=\"cpu\")\n\n        if isinstance(checkpoint, dict) and \"state_dict\" in checkpoint:\n            state_dict = checkpoint[\"state_dict\"]\n        else:\n            state_dict = checkpoint\n\n        model.load_state_dict(state_dict, strict=False) \n\n    self.model = model\n    return self.model\n</code></pre>"},{"location":"api/#ada_verona.PyTorchNetwork.load_pytorch_model","title":"<code>load_pytorch_model()</code>","text":"<p>Load the PyTorch model and wrap it in a TorchModelWrapper.</p> <p>Returns:</p> Type Description <code>Module</code> <p>torch.nn.Module: The wrapped PyTorch model.</p> Source code in <code>ada_verona/database/machine_learning_model/pytorch_network.py</code> <pre><code>def load_pytorch_model(self) -&gt; torch.nn.Module:\n    \"\"\"\n    Load the PyTorch model and wrap it in a TorchModelWrapper.\n\n    Returns:\n        torch.nn.Module: The wrapped PyTorch model.\n    \"\"\"\n    if self.torch_model_wrapper is None:\n        model = self.load_model()\n        device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n        model = model.to(device)\n        model.eval()\n\n        self.torch_model_wrapper = TorchModelWrapper(model, self.get_input_shape())\n\n    return self.torch_model_wrapper\n</code></pre>"},{"location":"api/#ada_verona.PyTorchNetwork.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert the PyTorchNetwork to a dictionary.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The dictionary representation of the PyTorchNetwork.</p> Source code in <code>ada_verona/database/machine_learning_model/pytorch_network.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"\n    Convert the PyTorchNetwork to a dictionary.\n\n    Returns:\n        dict: The dictionary representation of the PyTorchNetwork.\n    \"\"\"\n    return dict(\n        architecture=str(self.architecture),\n        weights=str(self.weights),\n        type=self.__class__.__name__,\n        module=self.__class__.__module__,\n    )\n</code></pre>"},{"location":"api/#ada_verona.TorchModelWrapper","title":"<code>TorchModelWrapper</code>","text":"<p>               Bases: <code>Module</code></p> <p>A wrapper class for a PyTorch model to reshape the input before passing it to the model.</p> Source code in <code>ada_verona/database/machine_learning_model/torch_model_wrapper.py</code> <pre><code>class TorchModelWrapper(torch.nn.Module):\n    \"\"\"\n    A wrapper class for a PyTorch model to reshape the input before passing it to the model.\n    \"\"\"\n\n    def __init__(self, torch_model: torch.nn.Module, input_shape: tuple[int]):\n        \"\"\"\n        Initialize the TorchModelWrapper with the given PyTorch model and input shape.\n\n        Args:\n            torch_model (torch.nn.Module): The PyTorch model to wrap.\n            input_shape: The input shape to reshape the input tensor. Can be tuple[int] or np.ndarray.\n        \"\"\"\n        super().__init__()\n        self.torch_model = torch_model\n        self.input_shape = input_shape\n\n    def forward(self, x):\n        \"\"\"\n        Forward pass of the TorchModelWrapper.\n\n        Args:\n            x (torch.Tensor): The input tensor.\n\n        Returns:\n            torch.Tensor: The output tensor from the wrapped PyTorch model.\n        \"\"\"\n\n        if isinstance(x, np.ndarray):\n        # ensure correct dtype/device if needed\n            x = torch.from_numpy(x).to(\n                dtype=torch.float32,\n                device=next(self.torch_model.parameters()).device\n            )\n            x = x.reshape(*self.input_shape)  # tuple unpacking\n\n        else:\n        # Assume it's already a torch.Tensor\n            x = x.reshape(*self.input_shape)\n\n        x = self.torch_model(x)\n        return x\n</code></pre>"},{"location":"api/#ada_verona.TorchModelWrapper.__init__","title":"<code>__init__(torch_model, input_shape)</code>","text":"<p>Initialize the TorchModelWrapper with the given PyTorch model and input shape.</p> <p>Parameters:</p> Name Type Description Default <code>torch_model</code> <code>Module</code> <p>The PyTorch model to wrap.</p> required <code>input_shape</code> <code>tuple[int]</code> <p>The input shape to reshape the input tensor. Can be tuple[int] or np.ndarray.</p> required Source code in <code>ada_verona/database/machine_learning_model/torch_model_wrapper.py</code> <pre><code>def __init__(self, torch_model: torch.nn.Module, input_shape: tuple[int]):\n    \"\"\"\n    Initialize the TorchModelWrapper with the given PyTorch model and input shape.\n\n    Args:\n        torch_model (torch.nn.Module): The PyTorch model to wrap.\n        input_shape: The input shape to reshape the input tensor. Can be tuple[int] or np.ndarray.\n    \"\"\"\n    super().__init__()\n    self.torch_model = torch_model\n    self.input_shape = input_shape\n</code></pre>"},{"location":"api/#ada_verona.TorchModelWrapper.forward","title":"<code>forward(x)</code>","text":"<p>Forward pass of the TorchModelWrapper.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Tensor</code> <p>The input tensor.</p> required <p>Returns:</p> Type Description <p>torch.Tensor: The output tensor from the wrapped PyTorch model.</p> Source code in <code>ada_verona/database/machine_learning_model/torch_model_wrapper.py</code> <pre><code>def forward(self, x):\n    \"\"\"\n    Forward pass of the TorchModelWrapper.\n\n    Args:\n        x (torch.Tensor): The input tensor.\n\n    Returns:\n        torch.Tensor: The output tensor from the wrapped PyTorch model.\n    \"\"\"\n\n    if isinstance(x, np.ndarray):\n    # ensure correct dtype/device if needed\n        x = torch.from_numpy(x).to(\n            dtype=torch.float32,\n            device=next(self.torch_model.parameters()).device\n        )\n        x = x.reshape(*self.input_shape)  # tuple unpacking\n\n    else:\n    # Assume it's already a torch.Tensor\n        x = x.reshape(*self.input_shape)\n\n    x = self.torch_model(x)\n    return x\n</code></pre>"},{"location":"api/#ada_verona.VNNLibProperty","title":"<code>VNNLibProperty</code>  <code>dataclass</code>","text":"<p>Dataclass for a VNNLib property.</p> Source code in <code>ada_verona/database/vnnlib_property.py</code> <pre><code>@dataclass\nclass VNNLibProperty:\n    \"\"\"Dataclass for a VNNLib property.\"\"\"\n\n    name: str\n    content: str\n    path: Path = None\n</code></pre>"},{"location":"api/#ada_verona.VerificationContext","title":"<code>VerificationContext</code>","text":"<p>A class to represent the context for verification. This class saves all the relevant information for a verification run.</p> Source code in <code>ada_verona/database/verification_context.py</code> <pre><code>class VerificationContext:\n    \"\"\"\n    A class to represent the context for verification.\n    This class saves all the relevant information for a verification run.\n    \"\"\"\n\n    def __init__(\n        self,\n        network: Network,\n        data_point: DataPoint,\n        tmp_path: Path,\n        property_generator: PropertyGenerator,\n        save_epsilon_results: bool = True,\n    ) -&gt; None:\n        \"\"\"\n        Initialize the VerificationContext with the given parameters.\n\n        Args:\n            network (Network): The network to be verified.\n            data_point (DataPoint): The data point to be verified.\n            tmp_path (Path): The temporary path for saving intermediate results.\n            property_generator (PropertyGenerator): The property generator for creating verification properties.\n            save_epsilon_results (bool, optional): Whether to save epsilon results. Defaults to True.\n        \"\"\"\n        self.network = network\n        self.data_point = data_point\n        self.tmp_path = tmp_path\n        self.property_generator = property_generator\n        self.save_epsilon_results = save_epsilon_results\n\n        if save_epsilon_results and not self.tmp_path.exists():\n            self.tmp_path.mkdir(parents=True)\n\n    def get_dict_for_epsilon_result(self) -&gt; dict:\n        \"\"\"\n        Get a dictionary representation of the epsilon result.\n\n        Returns:\n            dict: The dictionary representation of the epsilon result.\n        \"\"\"\n        return dict(\n            network_path=self.network.path.resolve(),\n            image_id=self.data_point.id,\n            original_label=self.data_point.label,\n            tmp_path=self.tmp_path.resolve(),\n            **self.property_generator.get_dict_for_epsilon_result(),\n        )\n\n    def save_vnnlib_property(self, vnnlib_property: VNNLibProperty) -&gt; None:\n        \"\"\"\n        Save the VNNLib property to a file in the temporary path.\n\n        Args:\n            vnnlib_property (VNNLibProperty): The VNNLib property object to be saved.\n        \"\"\"\n        if not self.tmp_path.exists():\n            self.tmp_path.mkdir(parents=True)\n        save_path = self.tmp_path / f\"{vnnlib_property.name}.vnnlib\"\n\n        with open(save_path, \"w\") as f:\n            f.write(vnnlib_property.content)\n        vnnlib_property.path = save_path\n\n    def delete_tmp_path(self) -&gt; None:\n        \"\"\"\n        Delete the temporary path and its contents.\n        \"\"\"\n\n\n        self.tmp_path.unlink()\n\n\n    def save_status_list(self, epsilon_status_list: list[EpsilonStatus]) -&gt; None:\n        \"\"\"\n        Save the list of epsilon statuses to a CSV file.\n\n        Args:\n            epsilon_status_list (list[EpsilonStatus]): The list of epsilon statuses to save.\n        \"\"\"\n        save_path = self.tmp_path / \"epsilon_results.csv\"\n        data = [x.to_dict() for x in epsilon_status_list]\n        df = pd.DataFrame(data=data)\n        df.to_csv(save_path)\n\n    def save_result(self, result: EpsilonStatus) -&gt; None:\n        \"\"\"\n        Save a single epsilon status result to the CSV file.\n\n        Args:\n            result (EpsilonStatus): The epsilon status result to save.\n        \"\"\"\n        if self.save_epsilon_results:\n            result_df_path = self.tmp_path / \"epsilons_df.csv\"\n            if result_df_path.exists():\n                df = pd.read_csv(result_df_path, index_col=0)\n                df.loc[len(df.index)] = result.to_dict()\n            else:\n                df = pd.DataFrame([result.to_dict()])\n            df.to_csv(result_df_path)\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"\n        Convert the VerificationContext to a dictionary.\n\n        Returns:\n            dict: The dictionary representation of the VerificationContext.\n        \"\"\"\n        return {\n            \"network\": self.network.to_dict(),\n            \"data_point\": self.data_point.to_dict(),\n            \"tmp_path\": str(self.tmp_path),\n            \"property_generator\": self.property_generator.to_dict(),\n            \"save_epsilon_results\": self.save_epsilon_results,\n        }\n\n    @classmethod\n    def from_dict(cls, data: dict) -&gt; \"VerificationContext\":\n        \"\"\"\n        Create a VerificationContext from a dictionary.\n\n        Args:\n            data (dict): The dictionary containing the VerificationContext attributes.\n\n        Returns:\n            VerificationContext: The created VerificationContext.\n        \"\"\"\n        # Recreate the network from its dictionary representation\n\n        network = Network.from_dict(data[\"network\"]) \n        data_point = DataPoint.from_dict(data[\"data_point\"])\n        tmp_path = Path(data[\"tmp_path\"])\n        property_generator = PropertyGenerator.from_dict(data[\"property_generator\"])\n        save_epsilon_results = data[\"save_epsilon_results\"]\n        return cls(\n            network=network,\n            data_point=data_point,\n            tmp_path=tmp_path,\n            property_generator=property_generator,\n            save_epsilon_results=save_epsilon_results,\n        )\n</code></pre>"},{"location":"api/#ada_verona.VerificationContext.__init__","title":"<code>__init__(network, data_point, tmp_path, property_generator, save_epsilon_results=True)</code>","text":"<p>Initialize the VerificationContext with the given parameters.</p> <p>Parameters:</p> Name Type Description Default <code>network</code> <code>Network</code> <p>The network to be verified.</p> required <code>data_point</code> <code>DataPoint</code> <p>The data point to be verified.</p> required <code>tmp_path</code> <code>Path</code> <p>The temporary path for saving intermediate results.</p> required <code>property_generator</code> <code>PropertyGenerator</code> <p>The property generator for creating verification properties.</p> required <code>save_epsilon_results</code> <code>bool</code> <p>Whether to save epsilon results. Defaults to True.</p> <code>True</code> Source code in <code>ada_verona/database/verification_context.py</code> <pre><code>def __init__(\n    self,\n    network: Network,\n    data_point: DataPoint,\n    tmp_path: Path,\n    property_generator: PropertyGenerator,\n    save_epsilon_results: bool = True,\n) -&gt; None:\n    \"\"\"\n    Initialize the VerificationContext with the given parameters.\n\n    Args:\n        network (Network): The network to be verified.\n        data_point (DataPoint): The data point to be verified.\n        tmp_path (Path): The temporary path for saving intermediate results.\n        property_generator (PropertyGenerator): The property generator for creating verification properties.\n        save_epsilon_results (bool, optional): Whether to save epsilon results. Defaults to True.\n    \"\"\"\n    self.network = network\n    self.data_point = data_point\n    self.tmp_path = tmp_path\n    self.property_generator = property_generator\n    self.save_epsilon_results = save_epsilon_results\n\n    if save_epsilon_results and not self.tmp_path.exists():\n        self.tmp_path.mkdir(parents=True)\n</code></pre>"},{"location":"api/#ada_verona.VerificationContext.delete_tmp_path","title":"<code>delete_tmp_path()</code>","text":"<p>Delete the temporary path and its contents.</p> Source code in <code>ada_verona/database/verification_context.py</code> <pre><code>def delete_tmp_path(self) -&gt; None:\n    \"\"\"\n    Delete the temporary path and its contents.\n    \"\"\"\n\n\n    self.tmp_path.unlink()\n</code></pre>"},{"location":"api/#ada_verona.VerificationContext.from_dict","title":"<code>from_dict(data)</code>  <code>classmethod</code>","text":"<p>Create a VerificationContext from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>The dictionary containing the VerificationContext attributes.</p> required <p>Returns:</p> Name Type Description <code>VerificationContext</code> <code>VerificationContext</code> <p>The created VerificationContext.</p> Source code in <code>ada_verona/database/verification_context.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: dict) -&gt; \"VerificationContext\":\n    \"\"\"\n    Create a VerificationContext from a dictionary.\n\n    Args:\n        data (dict): The dictionary containing the VerificationContext attributes.\n\n    Returns:\n        VerificationContext: The created VerificationContext.\n    \"\"\"\n    # Recreate the network from its dictionary representation\n\n    network = Network.from_dict(data[\"network\"]) \n    data_point = DataPoint.from_dict(data[\"data_point\"])\n    tmp_path = Path(data[\"tmp_path\"])\n    property_generator = PropertyGenerator.from_dict(data[\"property_generator\"])\n    save_epsilon_results = data[\"save_epsilon_results\"]\n    return cls(\n        network=network,\n        data_point=data_point,\n        tmp_path=tmp_path,\n        property_generator=property_generator,\n        save_epsilon_results=save_epsilon_results,\n    )\n</code></pre>"},{"location":"api/#ada_verona.VerificationContext.get_dict_for_epsilon_result","title":"<code>get_dict_for_epsilon_result()</code>","text":"<p>Get a dictionary representation of the epsilon result.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The dictionary representation of the epsilon result.</p> Source code in <code>ada_verona/database/verification_context.py</code> <pre><code>def get_dict_for_epsilon_result(self) -&gt; dict:\n    \"\"\"\n    Get a dictionary representation of the epsilon result.\n\n    Returns:\n        dict: The dictionary representation of the epsilon result.\n    \"\"\"\n    return dict(\n        network_path=self.network.path.resolve(),\n        image_id=self.data_point.id,\n        original_label=self.data_point.label,\n        tmp_path=self.tmp_path.resolve(),\n        **self.property_generator.get_dict_for_epsilon_result(),\n    )\n</code></pre>"},{"location":"api/#ada_verona.VerificationContext.save_result","title":"<code>save_result(result)</code>","text":"<p>Save a single epsilon status result to the CSV file.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>EpsilonStatus</code> <p>The epsilon status result to save.</p> required Source code in <code>ada_verona/database/verification_context.py</code> <pre><code>def save_result(self, result: EpsilonStatus) -&gt; None:\n    \"\"\"\n    Save a single epsilon status result to the CSV file.\n\n    Args:\n        result (EpsilonStatus): The epsilon status result to save.\n    \"\"\"\n    if self.save_epsilon_results:\n        result_df_path = self.tmp_path / \"epsilons_df.csv\"\n        if result_df_path.exists():\n            df = pd.read_csv(result_df_path, index_col=0)\n            df.loc[len(df.index)] = result.to_dict()\n        else:\n            df = pd.DataFrame([result.to_dict()])\n        df.to_csv(result_df_path)\n</code></pre>"},{"location":"api/#ada_verona.VerificationContext.save_status_list","title":"<code>save_status_list(epsilon_status_list)</code>","text":"<p>Save the list of epsilon statuses to a CSV file.</p> <p>Parameters:</p> Name Type Description Default <code>epsilon_status_list</code> <code>list[EpsilonStatus]</code> <p>The list of epsilon statuses to save.</p> required Source code in <code>ada_verona/database/verification_context.py</code> <pre><code>def save_status_list(self, epsilon_status_list: list[EpsilonStatus]) -&gt; None:\n    \"\"\"\n    Save the list of epsilon statuses to a CSV file.\n\n    Args:\n        epsilon_status_list (list[EpsilonStatus]): The list of epsilon statuses to save.\n    \"\"\"\n    save_path = self.tmp_path / \"epsilon_results.csv\"\n    data = [x.to_dict() for x in epsilon_status_list]\n    df = pd.DataFrame(data=data)\n    df.to_csv(save_path)\n</code></pre>"},{"location":"api/#ada_verona.VerificationContext.save_vnnlib_property","title":"<code>save_vnnlib_property(vnnlib_property)</code>","text":"<p>Save the VNNLib property to a file in the temporary path.</p> <p>Parameters:</p> Name Type Description Default <code>vnnlib_property</code> <code>VNNLibProperty</code> <p>The VNNLib property object to be saved.</p> required Source code in <code>ada_verona/database/verification_context.py</code> <pre><code>def save_vnnlib_property(self, vnnlib_property: VNNLibProperty) -&gt; None:\n    \"\"\"\n    Save the VNNLib property to a file in the temporary path.\n\n    Args:\n        vnnlib_property (VNNLibProperty): The VNNLib property object to be saved.\n    \"\"\"\n    if not self.tmp_path.exists():\n        self.tmp_path.mkdir(parents=True)\n    save_path = self.tmp_path / f\"{vnnlib_property.name}.vnnlib\"\n\n    with open(save_path, \"w\") as f:\n        f.write(vnnlib_property.content)\n    vnnlib_property.path = save_path\n</code></pre>"},{"location":"api/#ada_verona.VerificationContext.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert the VerificationContext to a dictionary.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The dictionary representation of the VerificationContext.</p> Source code in <code>ada_verona/database/verification_context.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"\n    Convert the VerificationContext to a dictionary.\n\n    Returns:\n        dict: The dictionary representation of the VerificationContext.\n    \"\"\"\n    return {\n        \"network\": self.network.to_dict(),\n        \"data_point\": self.data_point.to_dict(),\n        \"tmp_path\": str(self.tmp_path),\n        \"property_generator\": self.property_generator.to_dict(),\n        \"save_epsilon_results\": self.save_epsilon_results,\n    }\n</code></pre>"},{"location":"api/#ada_verona.VerificationModule","title":"<code>VerificationModule</code>","text":"<p>               Bases: <code>ABC</code></p> Source code in <code>ada_verona/verification_module/verification_module.py</code> <pre><code>class VerificationModule(ABC):\n    @abstractmethod\n    def verify(self, verification_context: VerificationContext, epsilon: float) -&gt; str | CompleteVerificationData:\n        \"\"\"Main method to verify an image for a given network and epsilon value\"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"api/#ada_verona.VerificationModule.verify","title":"<code>verify(verification_context, epsilon)</code>  <code>abstractmethod</code>","text":"<p>Main method to verify an image for a given network and epsilon value</p> Source code in <code>ada_verona/verification_module/verification_module.py</code> <pre><code>@abstractmethod\ndef verify(self, verification_context: VerificationContext, epsilon: float) -&gt; str | CompleteVerificationData:\n    \"\"\"Main method to verify an image for a given network and epsilon value\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/#ada_verona.VerificationResult","title":"<code>VerificationResult</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Class for saving the possible verification results. At this point we are using the same Result strings for complete verification and attacks.</p> Source code in <code>ada_verona/database/verification_result.py</code> <pre><code>class VerificationResult(str, Enum):\n    \"\"\"Class for saving the possible verification results.\n    At this point we are using the same Result strings for complete verification and attacks.\n    \"\"\"\n\n    UNSAT = \"UNSAT\"\n    SAT = \"SAT\"\n    TIMEOUT = \"TIMEOUT\"\n    ERROR = \"ERR\"\n</code></pre>"},{"location":"how-to-guides/","title":"How to guides","text":"<p>To help you get up and running with ada-verona, we provide a tutorial notebook and a collection of example scripts:</p> <ul> <li> <p>Main Guide:</p> <ul> <li>The primary resource for learning how to use VERONA is the Jupyter notebook found in the <code>notebooks</code> folder. This tutorial notebook offers an overview of the package components, step-by-step instructions, and practical demonstrations of typical workflows. We highly recommend starting here to understand the core concepts and capabilities of the package.</li> </ul> </li> <li> <p>Quick-Start Example Scripts:</p> <ul> <li>The <code>scripts</code> folder contains a variety of example scripts designed to help you get started quickly with ada-verona. These scripts cover common use cases and can be run directly (from within the <code>scripts</code> folder) to see how to perform tasks such as:<ul> <li>Running VERONA with a custom dataset and ab-crown (<code>create_robustness_distribution_from_test_dataset.py</code>).</li> <li>Loading a PyTorch dataset and running VERONA with one-to-any or one-to-one verification (<code>create_robustness_dist_on_pytorch_dataset.py</code>).</li> <li>Distributing jobs across multiple nodes using SLURM for large-scale experiments (<code>multiple_jobs</code> folder), including distributing tasks over CPU and GPU for different verifiers in the same experiment.</li> <li>Using auto-verify integration (<code>create_robustness_dist_with_auto_verify.py</code>).</li> </ul> </li> </ul> </li> </ul> <p>The notebook is your main entry point for learning and understanding the package, while the scripts serve as practical templates and quick-start resources for your own experiments.</p>"},{"location":"how-to-guides/#setting-up-the-experiment-directory","title":"Setting up the Experiment Directory","text":"<p>The experiment directory structure by default is expected as follows:</p> <p>Note: You must provide ONNX or torch network files in the networks directory. ada-verona will create directories automatically, but you need to supply your own network models. <pre><code>experiment/\n|-- data/\n|   |-- labels.csv\n|   |-- images/\n|       |-- mnist_0.npy\n|       |-- mnist_1.npy\n|       |-- ...\n|-- networks/\n|   |-- mnist-net_256x2.onnx\n|   |-- mnist-net_256x4.onnx\n|   |-- ...\n</code></pre></p>"},{"location":"how-to-guides/#verification","title":"Verification","text":""},{"location":"how-to-guides/#auto-verify","title":"Auto-Verify","text":"<p>VERONA features a plugin architecture through the <code>AutoVerifyModule</code> which allows integration with auto-verify when it's installed in the same environment.  AutoVerify handles installation of various verifiers (see next section) as well as configuration and execution of the verifiers. </p> <p>This design provides several benefits:</p> <ol> <li>Independence: VERONA works perfectly without auto-verify, using attack-based verification methods for empirical upper bounds.</li> <li>Automatic Detection: When auto-verify is installed in the same environment, its verifiers become automatically available</li> <li>Interface: The same API works regardless of which verification backend is used</li> </ol> <p>Auto-Verify can be installed in the following way: </p> <p><pre><code>uv pip install auto-verify&gt;=0.1.4\n</code></pre> It is important to note that in order to use AutoVerify in VERONA, the pip version for AutoVerify should be &gt;=0.1.4.</p>"},{"location":"how-to-guides/#available-verifiers","title":"Available Verifiers","text":"<p>Currently, auto-verify supports nnenum, AB-Crown, VeriNet, and Oval-Bab. We thank the authors and maintainers of these projects for their contributions to the robustness research community.</p> <p>We plan to add more verifiers to auto-verify in the future. For additional information about auto-verify, please refer to the official GitHub repository and documentation. Verifiers can be installed using the <code>auto-verify</code> command, e.g. to install nnenum and abcrown:</p> <p><pre><code>auto-verify install nnenum abcrown\n</code></pre> To see the current configuration of auto-verify, you can use the <code>auto-verify config show</code> command.</p> <pre><code>auto-verify config show\n</code></pre>"},{"location":"how-to-guides/#possible-extension-how-to-add-your-own-verifier","title":"Possible Extension: How to Add Your Own Verifier","text":"<p>Custom verifiers can be added to VERONA by using the <code>VerificationModule</code> interface.</p> <p>Implement new verifiers using the <code>VerificationModule</code> class:</p> <ul> <li>Create a new class that inherits from <code>VerificationModule</code>.</li> <li>Implement the <code>verify(self, verification_context: VerificationContext, epsilon: float)</code> method. This method should return either a string (e.g., \"SAT\", \"UNSAT\", \"ERR\") or a <code>CompleteVerificationData</code> object.</li> </ul> <p>Example: <pre><code>from ada_verona.verification_module.verification_module import VerificationModule\n\nclass MyCustomVerifier(VerificationModule):\n    def verify(self, verification_context, epsilon):\n        # Your custom verification logic here\n        # Return \"SAT\", \"UNSAT\", or a CompleteVerificationData object\n        return \"UNSAT\"\n</code></pre></p>"},{"location":"how-to-guides/#adversarial-attacks","title":"Adversarial Attacks","text":"<p>VERONA implements the following adversarial attack methods:</p> <ul> <li>Fast Gradient Sign Method (FGSM) - Goodfellow et al., 2015</li> <li>Projected Gradient Descent (PGD) - Madry et al., 2018</li> <li>AutoAttack - Croce and Hein, 2020</li> </ul>"},{"location":"how-to-guides/#optional-autoattack-installation","title":"Optional: AutoAttack Installation","text":"<p>To use the <code>AutoAttackWrapper</code> class, you need to install AutoAttack separately from its GitHub repository:</p> <pre><code>uv pip install git+https://github.com/fra31/auto-attack\n</code></pre> <p>This package provides ensemble-based adversarial attacks for robustness evaluation. When installed, <code>AutoAttackWrapper</code> becomes automatically available in <code>ada_verona</code>.</p>"},{"location":"how-to-guides/#possible-extension-custom-attacks","title":"Possible Extension: Custom Attacks","text":"<p>Custom attacks can be implemented by using the <code>Attack</code> interface.</p>"},{"location":"pytorch_support/","title":"Pytorch support","text":""},{"location":"pytorch_support/#pytorch-model-support-in-verona","title":"PyTorch Model Support in VERONA","text":"<p>This document describes how to use PyTorch models directly in VERONA, eliminating the need for ONNX conversion while maintaining backward compatibility.</p>"},{"location":"pytorch_support/#overview","title":"Overview","text":"<p>VERONA now supports both ONNX and PyTorch models through a unified interface. This allows you to:</p> <ul> <li>Use PyTorch models directly without ONNX conversion. </li> <li>Maintain existing ONNX workflows. </li> <li>Mix both model types in the same experiment</li> <li>Leverage PyTorch-specific features for attacks and verification.</li> </ul>"},{"location":"pytorch_support/#networks-csv-file","title":"Networks CSV File","text":"<p>Create a networks.csv file in your /networks/ directory with the following structure:</p> <p><code>name,network_type,architecture,weights</code></p>"},{"location":"pytorch_support/#required-fields","title":"Required Fields","text":"<p>network_type: Either \"onnx\" or \"pytorch\" architecture: Path to Python file containing model definition (required for PyTorch networks) or to .onnx path weights: Path to weights file (required for PyTorch networks)</p>"},{"location":"pytorch_support/#pytorch-model-architecture-files","title":"PyTorch Model Architecture Files","text":"<p>Your PyTorch model architecture file should contain a model class that inherits from torch.nn.Module.  Furthermore, the file should contain some information about the required shape of the input.  The file should either define a model instance at module level:</p> <pre><code>import torch.nn as nn\n\nEXPECTED_INPUT_SHAPE = ..\n\nclass ResNet18(nn.Module):\n\n    def __init__(self, num_classes=10):\n\n        super().__init__()\n\n        # ... model definition ...\n\n\n\n    def forward(self, x):\n\n        # ... forward pass ...\n\n        return x\n</code></pre> <p>Instead of the global variable <code>EXPECTED_INPUT_SHAPE</code> you could also add the following function:</p> <pre><code>def get_input_shape()-&gt;list[int]:\n    return ...\n</code></pre>"},{"location":"pytorch_support/#create-model-instance-for-easy-loading","title":"Create model instance for easy loading","text":"<pre><code>resnet18_model = ResNet18(num_classes=10)\n</code></pre> <p>Define a function that creates and returns the model:</p> <pre><code>import torch.nn as nn\n\ndef create_resnet18(num_classes=10):\n\n    model = ResNet18(num_classes=num_classes)\n\n    return model\n\nclass ResNet18(nn.Module):\n\n    # ... model definition ...\n</code></pre>"},{"location":"pytorch_support/#weights-files","title":"Weights Files","text":"<p>Store your trained model weights in .pt or .pth files. These should contain the state dictionary of your PyTorch model.</p>"},{"location":"pytorch_support/#both-onnx-and-pytorch-networks-implement-the-same-interface","title":"Both ONNX and PyTorch networks implement the same interface","text":"<p>In the normal pipeline of VERONA, the networks are created within the ExperimentRepository like so:</p> <pre><code>networks = experiment_repository.get_network_list()\n</code></pre> <p>However it is also possible to instantiate your own networks: </p> <pre><code>from .database.machine_learning_model.network import Network\n\n\n#create onnx\n net_info = {\n        \"network_type\": \"onnx\", \n        \"architecture\": \"some/path/to/network.onnx\"\n }\n network = Network.from_file(net_info) \n\n#create pytorch\n net_info = {\n        \"network_type\": \"pytorch\", \n        \"architecture\": \"some/path/to/network/architecture.py\", \n        \"weights: \"some/path/to/network/weights.pth or .pt\"\n }\n network = Network.from_file(net_info) \n</code></pre> <p>Or if you want to create a network directly for a specific type, for example onnx. </p> <pre><code>from .database.machine_learning_model.onnx_network import OnnxNetwork\n\nnetwork = OnnxNetwork(\"./path/to/model.onnx\")\n</code></pre>"},{"location":"pytorch_support/#load-pytorch-model-works-for-both-types","title":"Load PyTorch model (works for both types)","text":"<p><code>pytorch_model = network.load_pytorch_model()</code></p>"},{"location":"pytorch_support/#get-network-name","title":"Get network name","text":"<p><code>network_name = network.name</code></p>"},{"location":"pytorch_support/#experiment-repository","title":"Experiment Repository","text":"<p>The ExperimentRepository.get_network_list() method now returns a list of Network objects instead of just ONNXNetwork objects.</p>"}]}