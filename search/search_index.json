{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"VERONA","text":"<p>VERONA is a lightweight Python package for setting up adversarial robustness experiments and to compute robustness distributions. The package implements adversarial attacks which can be extended with the auto-verify plugin to enable complete verification. </p>"},{"location":"#installation-and-environment-setup","title":"Installation and Environment Setup","text":""},{"location":"#create-virtual-environment-and-install-ada-verona","title":"Create Virtual Environment and install ada-verona","text":"<p>The python package for VERONA is called ada-verona, as our research group is called ADA.</p> <p>To run ada-verona, we recommend to set up a conda environment. We also recommend using miniforge as the package manager and using uv for dependency management.</p> <p>Create a new conda environment named <code>verona_env</code>: <pre><code>conda create -n verona_env python=3.10\nconda activate verona_env\n</code></pre></p>"},{"location":"#installing-the-package","title":"Installing the package","text":"<p>Inside the conda environment, install the ada-verona package:</p> <pre><code>uv pip install ada-verona\n</code></pre>"},{"location":"#gpu-version-installation","title":"GPU-version Installation","text":"<p>Note that the default installation is CPU-only, and that we recommend to install the GPU version for full functionality, as, e.g. AB-CROWN, heavily relies on GPU parallelization for practical performance. The package resolver will automatically resolve the correct version of the package for your system, depending on whether you have a GPU available, but you can also explicitly install the GPU version with the following command:</p> <pre><code>uv pip install ada-verona[gpu]\n</code></pre>"},{"location":"#local-installation-for-eg-development-purposes","title":"Local installation for e.g. development purposes","text":"<p>If you want to install ada-verona locally using git:</p> <pre><code>git clone https://github.com/ADA-research/VERONA.git\ncd VERONA\nuv pip install -e .\nuv pip install -e .[dev]  # to include development dependencies\n</code></pre>"},{"location":"#optional-autoattack-installation","title":"Optional: AutoAttack Installation","text":"<p>To use the AutoAttack adversarial attack wrapper (<code>AutoAttackWrapper</code>), you need to install AutoAttack from its GitHub repository:</p> <pre><code>uv pip install git+https://github.com/fra31/auto-attack\n</code></pre> <p>This package provides ensemble-based adversarial attacks for robustness evaluation, as described in the paper by Croce and Hein (2020).</p>"},{"location":"#optional-autoverify-installation","title":"Optional: AutoVerify Installation","text":"<p>To use the auto-verify verifiers, you need to install auto-verify separately:</p> <p>Note: On macOS (and sometimes on Linux), you may need to install <code>swig</code> first with <code>conda install -c conda-forge swig</code>.</p> <pre><code>uv pip install auto-verify&gt;=0.1.4\n</code></pre> <p>This package provides a framework for integrating verifiers. Please refer to the auto-verify documentation for details about auto-verify.</p>"},{"location":"#setting-up-pre-commit-hooks","title":"Setting up Pre-Commit Hooks","text":"<p>If you installed development dependencies (<code>uv pip install -e .[dev]</code>), pre-commit is already available. To install the git hooks, run:</p> <pre><code>pre-commit install\n</code></pre> <p>This will automatically enforce code quality standards before each commit.</p>"},{"location":"api/","title":"API","text":""},{"location":"api/#ada-verona","title":"ADA-VERONA","text":"<p>ADA-VERONA: Neural Network Robustness Analysis Framework</p> <p>A framework for analyzing neural network robustness through verification and adversarial testing.</p>"},{"location":"api/#ada_verona.AttackEstimationModule","title":"<code>AttackEstimationModule</code>","text":"<p>               Bases: <code>VerificationModule</code></p> <p>A module for estimating the robustness of a model against adversarial attacks.</p> Source code in <code>ada_verona/verification_module/attack_estimation_module.py</code> <pre><code>class AttackEstimationModule(VerificationModule):\n    \"\"\"\n    A module for estimating the robustness of a model against adversarial attacks.\n\n    \"\"\"\n\n    def __init__(self, attack: Attack, top_k: int = 1) -&gt; None:\n        \"\"\"\n        Initialize the AttackEstimationModule with a specific attack.\n\n        Args:\n            attack (Attack): The attack to be used for robustness estimation.\n            top_k: Number of top scores to take into account for checking the prediction.\n        \"\"\"\n        self.attack = attack\n        self.top_k = top_k\n        self.name = f\"AttackEstimationModule [{attack.name}, top-{top_k}]\"\n\n    def verify(self, verification_context: VerificationContext, epsilon: float) -&gt; str | CompleteVerificationData:\n        \"\"\"\n        Verify the robustness of the model within the given epsilon perturbation.\n\n        Args:\n            verification_context (VerificationContext): The context for verification, \n            including the model and data point.\n            epsilon (float): The perturbation magnitude for the attack.\n\n        Returns:\n            str | CompleteVerificationData: The result of the verification,\n                                either SAT or UNSAT, along with the duration.\n        \"\"\"\n\n        if isinstance(verification_context.property_generator, One2AnyPropertyGenerator):\n            # Check if the property generator is of type One2AnyPropertyGenerator\n\n            start = time.time()  \n            torch_model = verification_context.network.load_pytorch_model() \n            device = 'cuda' if torch.cuda.is_available() else 'cpu'  \n            target = verification_context.data_point.label  \n            target_on_device = torch.tensor([target], device=device)  \n            data_on_device = verification_context.data_point.data.clone().detach().to(device)  \n            perturbed_data = self.attack.execute(torch_model, data_on_device, target_on_device, epsilon)  \n\n            output = torch_model(perturbed_data) \n\n            _, predicted_labels = torch.topk(output, self.top_k) \n\n            duration = time.time() - start \n            if target in predicted_labels:\n                return CompleteVerificationData(result=VerificationResult.UNSAT, took=duration, \n                                                obtained_labels=predicted_labels)\n            else:\n                return CompleteVerificationData(result=VerificationResult.SAT, took=duration, \n                                                obtained_labels=predicted_labels)\n        else:\n            raise NotImplementedError(\"Currently, only one 2 any verification is implemented for adversarial attacks.\")\n</code></pre>"},{"location":"api/#ada_verona.AttackEstimationModule.__init__","title":"<code>__init__(attack, top_k=1)</code>","text":"<p>Initialize the AttackEstimationModule with a specific attack.</p> <p>Parameters:</p> Name Type Description Default <code>attack</code> <code>Attack</code> <p>The attack to be used for robustness estimation.</p> required <code>top_k</code> <code>int</code> <p>Number of top scores to take into account for checking the prediction.</p> <code>1</code> Source code in <code>ada_verona/verification_module/attack_estimation_module.py</code> <pre><code>def __init__(self, attack: Attack, top_k: int = 1) -&gt; None:\n    \"\"\"\n    Initialize the AttackEstimationModule with a specific attack.\n\n    Args:\n        attack (Attack): The attack to be used for robustness estimation.\n        top_k: Number of top scores to take into account for checking the prediction.\n    \"\"\"\n    self.attack = attack\n    self.top_k = top_k\n    self.name = f\"AttackEstimationModule [{attack.name}, top-{top_k}]\"\n</code></pre>"},{"location":"api/#ada_verona.AttackEstimationModule.verify","title":"<code>verify(verification_context, epsilon)</code>","text":"<p>Verify the robustness of the model within the given epsilon perturbation.</p> <p>Parameters:</p> Name Type Description Default <code>verification_context</code> <code>VerificationContext</code> <p>The context for verification, </p> required <code>epsilon</code> <code>float</code> <p>The perturbation magnitude for the attack.</p> required <p>Returns:</p> Type Description <code>str | CompleteVerificationData</code> <p>str | CompleteVerificationData: The result of the verification,                 either SAT or UNSAT, along with the duration.</p> Source code in <code>ada_verona/verification_module/attack_estimation_module.py</code> <pre><code>def verify(self, verification_context: VerificationContext, epsilon: float) -&gt; str | CompleteVerificationData:\n    \"\"\"\n    Verify the robustness of the model within the given epsilon perturbation.\n\n    Args:\n        verification_context (VerificationContext): The context for verification, \n        including the model and data point.\n        epsilon (float): The perturbation magnitude for the attack.\n\n    Returns:\n        str | CompleteVerificationData: The result of the verification,\n                            either SAT or UNSAT, along with the duration.\n    \"\"\"\n\n    if isinstance(verification_context.property_generator, One2AnyPropertyGenerator):\n        # Check if the property generator is of type One2AnyPropertyGenerator\n\n        start = time.time()  \n        torch_model = verification_context.network.load_pytorch_model() \n        device = 'cuda' if torch.cuda.is_available() else 'cpu'  \n        target = verification_context.data_point.label  \n        target_on_device = torch.tensor([target], device=device)  \n        data_on_device = verification_context.data_point.data.clone().detach().to(device)  \n        perturbed_data = self.attack.execute(torch_model, data_on_device, target_on_device, epsilon)  \n\n        output = torch_model(perturbed_data) \n\n        _, predicted_labels = torch.topk(output, self.top_k) \n\n        duration = time.time() - start \n        if target in predicted_labels:\n            return CompleteVerificationData(result=VerificationResult.UNSAT, took=duration, \n                                            obtained_labels=predicted_labels)\n        else:\n            return CompleteVerificationData(result=VerificationResult.SAT, took=duration, \n                                            obtained_labels=predicted_labels)\n    else:\n        raise NotImplementedError(\"Currently, only one 2 any verification is implemented for adversarial attacks.\")\n</code></pre>"},{"location":"api/#ada_verona.BinarySearchEpsilonValueEstimator","title":"<code>BinarySearchEpsilonValueEstimator</code>","text":"<p>               Bases: <code>EpsilonValueEstimator</code></p> <p>A class to get the critical epsilon value using binary search.</p> Source code in <code>ada_verona/epsilon_value_estimator/binary_search_epsilon_value_estimator.py</code> <pre><code>class BinarySearchEpsilonValueEstimator(EpsilonValueEstimator):\n    \"\"\"\n    A class to get the critical epsilon value using binary search.\n    \"\"\"\n\n    def compute_epsilon_value(self, verification_context: VerificationContext) -&gt; EpsilonValueResult:\n        \"\"\"\n        Compute the epsilon value using binary search.\n\n        Args:\n            verification_context (VerificationContext): The context for verification.\n\n        Returns:\n            EpsilonValueResult: The result of the epsilon value estimation.\n        \"\"\"\n        epsilon_status_list = [EpsilonStatus(x, None, None, self.verifier.name) for x in self.epsilon_value_list]\n\n        start_time = time.time()\n        highest_unsat_value, smallest_sat_value = self.binary_search(verification_context, epsilon_status_list)\n        duration = time.time() - start_time\n        epsilon_value_result = EpsilonValueResult(\n            verification_context=verification_context,\n            epsilon=highest_unsat_value,\n            smallest_sat_value=smallest_sat_value,\n            time=duration,\n            verifier = self.verifier.name,\n        )\n\n        logger.info(\n            f\"Verification Context: {verification_context.get_dict_for_epsilon_result()}, \"\n            f\"epsilon_result: {epsilon_value_result.epsilon}\"  \n        )\n        return epsilon_value_result\n\n    def get_highest_unsat(self, epsilon_status_list: list[EpsilonStatus]) -&gt; float:\n        \"\"\"\n        Get the highest UNSAT epsilon value from the list.\n\n        Args:\n            epsilon_status_list (list[EpsilonStatus]): The list of epsilon statuses.\n\n        Returns:\n            float: The highest UNSAT epsilon value.\n        \"\"\"\n        highest_unsat = None\n        if len([x.result for x in epsilon_status_list if x.result == VerificationResult.UNSAT]) &gt; 0:\n            highest_unsat = max(\n                [index for index, x in enumerate(epsilon_status_list) if x.result == VerificationResult.UNSAT]\n            )\n\n        highest_unsat_value = epsilon_status_list[highest_unsat].value if highest_unsat is not None else 0\n\n        return highest_unsat_value\n\n    def get_smallest_sat(self, epsilon_status_list: list[EpsilonStatus]) -&gt; float:\n        \"\"\"\n        Get the smallest SAT epsilon value from the list.\n\n        Args:\n            epsilon_status_list (list[EpsilonStatus]): The list of epsilon statuses.\n\n        Returns:\n            float: The smallest SAT epsilon value.\n        \"\"\"\n        try:\n            max_epsilon_value = max([x.value for x in epsilon_status_list])\n        except ValueError:\n            return 0\n        smallest_sat = None\n\n        if len([x.result for x in epsilon_status_list if x.result == VerificationResult.SAT]) &gt; 0:\n            smallest_sat = min(\n                [index for index, x in enumerate(epsilon_status_list) if x.result == VerificationResult.SAT]\n            )\n\n        smallest_sat_value = epsilon_status_list[smallest_sat].value if smallest_sat is not None else max_epsilon_value\n\n        return smallest_sat_value\n\n    def binary_search(\n        self, verification_context: VerificationContext, epsilon_status_list: list[EpsilonStatus]\n    ) -&gt; float:\n        \"\"\"\n        Perform binary search to find the highest UNSAT and smallest SAT epsilon values.\n\n        Args:\n            verification_context (VerificationContext): The context for verification.\n            epsilon_status_list (list[EpsilonStatus]): The list of epsilon statuses.\n\n        Returns:\n            float: The highest UNSAT and smallest SAT epsilon values.\n        \"\"\"\n        if len(epsilon_status_list) == 1:\n            outcome = self.verifier.verify(verification_context, epsilon_status_list[0].value)\n            epsilon_status_list[0].set_values(outcome)\n            logger.debug(f\"current epsilon value: {epsilon_status_list[0].result}, took: {epsilon_status_list[0].time}\")\n            verification_context.save_result(epsilon_status_list[0])\n            if epsilon_status_list[0].result == VerificationResult.UNSAT:\n                return epsilon_status_list[0].value, self.get_smallest_sat(epsilon_status_list)\n            else:\n                return 0, self.get_smallest_sat(epsilon_status_list)\n\n        first = 0\n        last = len(epsilon_status_list) - 1\n\n        while first &lt;= last:\n            midpoint = (first + last) // 2\n\n            if not epsilon_status_list[midpoint].result:\n                outcome = self.verifier.verify(verification_context, epsilon_status_list[midpoint].value)\n                epsilon_status_list[midpoint].set_values(outcome)\n                verification_context.save_result(epsilon_status_list[midpoint])\n                logger.debug(\n                    f\"current epsilon value: {epsilon_status_list[midpoint].result},\"\n                    f\"took: {epsilon_status_list[midpoint].time}\"  \n                )\n\n            if epsilon_status_list[midpoint].result == VerificationResult.UNSAT:\n                first = midpoint + 1\n            elif epsilon_status_list[midpoint].result == VerificationResult.SAT:\n                last = midpoint - 1\n            else:\n                epsilon_status_list.pop(midpoint)\n                last = last - 1\n\n        logger.debug(f\"epsilon status list: {[(x.value, x.result, x.time) for x in epsilon_status_list]}\")\n\n        highest_unsat_value = self.get_highest_unsat(epsilon_status_list)\n        smallest_sat_value = self.get_smallest_sat(epsilon_status_list)\n\n        return highest_unsat_value, smallest_sat_value\n</code></pre>"},{"location":"api/#ada_verona.BinarySearchEpsilonValueEstimator.binary_search","title":"<code>binary_search(verification_context, epsilon_status_list)</code>","text":"<p>Perform binary search to find the highest UNSAT and smallest SAT epsilon values.</p> <p>Parameters:</p> Name Type Description Default <code>verification_context</code> <code>VerificationContext</code> <p>The context for verification.</p> required <code>epsilon_status_list</code> <code>list[EpsilonStatus]</code> <p>The list of epsilon statuses.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The highest UNSAT and smallest SAT epsilon values.</p> Source code in <code>ada_verona/epsilon_value_estimator/binary_search_epsilon_value_estimator.py</code> <pre><code>def binary_search(\n    self, verification_context: VerificationContext, epsilon_status_list: list[EpsilonStatus]\n) -&gt; float:\n    \"\"\"\n    Perform binary search to find the highest UNSAT and smallest SAT epsilon values.\n\n    Args:\n        verification_context (VerificationContext): The context for verification.\n        epsilon_status_list (list[EpsilonStatus]): The list of epsilon statuses.\n\n    Returns:\n        float: The highest UNSAT and smallest SAT epsilon values.\n    \"\"\"\n    if len(epsilon_status_list) == 1:\n        outcome = self.verifier.verify(verification_context, epsilon_status_list[0].value)\n        epsilon_status_list[0].set_values(outcome)\n        logger.debug(f\"current epsilon value: {epsilon_status_list[0].result}, took: {epsilon_status_list[0].time}\")\n        verification_context.save_result(epsilon_status_list[0])\n        if epsilon_status_list[0].result == VerificationResult.UNSAT:\n            return epsilon_status_list[0].value, self.get_smallest_sat(epsilon_status_list)\n        else:\n            return 0, self.get_smallest_sat(epsilon_status_list)\n\n    first = 0\n    last = len(epsilon_status_list) - 1\n\n    while first &lt;= last:\n        midpoint = (first + last) // 2\n\n        if not epsilon_status_list[midpoint].result:\n            outcome = self.verifier.verify(verification_context, epsilon_status_list[midpoint].value)\n            epsilon_status_list[midpoint].set_values(outcome)\n            verification_context.save_result(epsilon_status_list[midpoint])\n            logger.debug(\n                f\"current epsilon value: {epsilon_status_list[midpoint].result},\"\n                f\"took: {epsilon_status_list[midpoint].time}\"  \n            )\n\n        if epsilon_status_list[midpoint].result == VerificationResult.UNSAT:\n            first = midpoint + 1\n        elif epsilon_status_list[midpoint].result == VerificationResult.SAT:\n            last = midpoint - 1\n        else:\n            epsilon_status_list.pop(midpoint)\n            last = last - 1\n\n    logger.debug(f\"epsilon status list: {[(x.value, x.result, x.time) for x in epsilon_status_list]}\")\n\n    highest_unsat_value = self.get_highest_unsat(epsilon_status_list)\n    smallest_sat_value = self.get_smallest_sat(epsilon_status_list)\n\n    return highest_unsat_value, smallest_sat_value\n</code></pre>"},{"location":"api/#ada_verona.BinarySearchEpsilonValueEstimator.compute_epsilon_value","title":"<code>compute_epsilon_value(verification_context)</code>","text":"<p>Compute the epsilon value using binary search.</p> <p>Parameters:</p> Name Type Description Default <code>verification_context</code> <code>VerificationContext</code> <p>The context for verification.</p> required <p>Returns:</p> Name Type Description <code>EpsilonValueResult</code> <code>EpsilonValueResult</code> <p>The result of the epsilon value estimation.</p> Source code in <code>ada_verona/epsilon_value_estimator/binary_search_epsilon_value_estimator.py</code> <pre><code>def compute_epsilon_value(self, verification_context: VerificationContext) -&gt; EpsilonValueResult:\n    \"\"\"\n    Compute the epsilon value using binary search.\n\n    Args:\n        verification_context (VerificationContext): The context for verification.\n\n    Returns:\n        EpsilonValueResult: The result of the epsilon value estimation.\n    \"\"\"\n    epsilon_status_list = [EpsilonStatus(x, None, None, self.verifier.name) for x in self.epsilon_value_list]\n\n    start_time = time.time()\n    highest_unsat_value, smallest_sat_value = self.binary_search(verification_context, epsilon_status_list)\n    duration = time.time() - start_time\n    epsilon_value_result = EpsilonValueResult(\n        verification_context=verification_context,\n        epsilon=highest_unsat_value,\n        smallest_sat_value=smallest_sat_value,\n        time=duration,\n        verifier = self.verifier.name,\n    )\n\n    logger.info(\n        f\"Verification Context: {verification_context.get_dict_for_epsilon_result()}, \"\n        f\"epsilon_result: {epsilon_value_result.epsilon}\"  \n    )\n    return epsilon_value_result\n</code></pre>"},{"location":"api/#ada_verona.BinarySearchEpsilonValueEstimator.get_highest_unsat","title":"<code>get_highest_unsat(epsilon_status_list)</code>","text":"<p>Get the highest UNSAT epsilon value from the list.</p> <p>Parameters:</p> Name Type Description Default <code>epsilon_status_list</code> <code>list[EpsilonStatus]</code> <p>The list of epsilon statuses.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The highest UNSAT epsilon value.</p> Source code in <code>ada_verona/epsilon_value_estimator/binary_search_epsilon_value_estimator.py</code> <pre><code>def get_highest_unsat(self, epsilon_status_list: list[EpsilonStatus]) -&gt; float:\n    \"\"\"\n    Get the highest UNSAT epsilon value from the list.\n\n    Args:\n        epsilon_status_list (list[EpsilonStatus]): The list of epsilon statuses.\n\n    Returns:\n        float: The highest UNSAT epsilon value.\n    \"\"\"\n    highest_unsat = None\n    if len([x.result for x in epsilon_status_list if x.result == VerificationResult.UNSAT]) &gt; 0:\n        highest_unsat = max(\n            [index for index, x in enumerate(epsilon_status_list) if x.result == VerificationResult.UNSAT]\n        )\n\n    highest_unsat_value = epsilon_status_list[highest_unsat].value if highest_unsat is not None else 0\n\n    return highest_unsat_value\n</code></pre>"},{"location":"api/#ada_verona.BinarySearchEpsilonValueEstimator.get_smallest_sat","title":"<code>get_smallest_sat(epsilon_status_list)</code>","text":"<p>Get the smallest SAT epsilon value from the list.</p> <p>Parameters:</p> Name Type Description Default <code>epsilon_status_list</code> <code>list[EpsilonStatus]</code> <p>The list of epsilon statuses.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The smallest SAT epsilon value.</p> Source code in <code>ada_verona/epsilon_value_estimator/binary_search_epsilon_value_estimator.py</code> <pre><code>def get_smallest_sat(self, epsilon_status_list: list[EpsilonStatus]) -&gt; float:\n    \"\"\"\n    Get the smallest SAT epsilon value from the list.\n\n    Args:\n        epsilon_status_list (list[EpsilonStatus]): The list of epsilon statuses.\n\n    Returns:\n        float: The smallest SAT epsilon value.\n    \"\"\"\n    try:\n        max_epsilon_value = max([x.value for x in epsilon_status_list])\n    except ValueError:\n        return 0\n    smallest_sat = None\n\n    if len([x.result for x in epsilon_status_list if x.result == VerificationResult.SAT]) &gt; 0:\n        smallest_sat = min(\n            [index for index, x in enumerate(epsilon_status_list) if x.result == VerificationResult.SAT]\n        )\n\n    smallest_sat_value = epsilon_status_list[smallest_sat].value if smallest_sat is not None else max_epsilon_value\n\n    return smallest_sat_value\n</code></pre>"},{"location":"api/#ada_verona.EpsilonStatus","title":"<code>EpsilonStatus</code>  <code>dataclass</code>","text":"<p>A class to represent the status of the verification. It records the epsilon value, the result (SAT, UNSAT, TIMEOUT, ERROR) and running time.</p> Source code in <code>ada_verona/database/epsilon_status.py</code> <pre><code>@dataclass\nclass EpsilonStatus:\n    \"\"\"\n    A class to represent the status of the verification.\n    It records the epsilon value, the result (SAT, UNSAT, TIMEOUT, ERROR) and running time.\n    \"\"\"\n\n    value: float\n    result: VerificationResult | None\n    time: float = None\n    verifier: str = None\n    obtained_labels: list[int] = None\n\n    def set_values(self, complete_verification_data: CompleteVerificationData):\n        \"\"\"\n        Set values from the CompleteVerificationData\n\n        Args:\n            complete_verification_data: CompleteVerificationData\n        \"\"\"\n        self.result = complete_verification_data.result\n        self.time = complete_verification_data.took\n        self.obtained_labels = getattr(complete_verification_data, \"obtained_labels\", None)\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"Convert the EpsilonStatus to a dictionary.\"\"\"\n        obtained_labels_value = None\n        if self.obtained_labels is not None:\n            if isinstance(self.obtained_labels, np.ndarray):\n                obtained_labels_value = self.obtained_labels.flatten().tolist()\n            elif isinstance(self.obtained_labels, list):\n                obtained_labels_value = self.obtained_labels\n            else:\n                obtained_labels_value = [self.obtained_labels]\n\n        return dict(\n            epsilon_value=self.value,\n            result=self.result,\n            time=self.time,\n            verifier=self.verifier,\n            obtained_labels=obtained_labels_value,\n        )\n</code></pre>"},{"location":"api/#ada_verona.EpsilonStatus.set_values","title":"<code>set_values(complete_verification_data)</code>","text":"<p>Set values from the CompleteVerificationData</p> <p>Parameters:</p> Name Type Description Default <code>complete_verification_data</code> <code>CompleteVerificationData</code> <p>CompleteVerificationData</p> required Source code in <code>ada_verona/database/epsilon_status.py</code> <pre><code>def set_values(self, complete_verification_data: CompleteVerificationData):\n    \"\"\"\n    Set values from the CompleteVerificationData\n\n    Args:\n        complete_verification_data: CompleteVerificationData\n    \"\"\"\n    self.result = complete_verification_data.result\n    self.time = complete_verification_data.took\n    self.obtained_labels = getattr(complete_verification_data, \"obtained_labels\", None)\n</code></pre>"},{"location":"api/#ada_verona.EpsilonStatus.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert the EpsilonStatus to a dictionary.</p> Source code in <code>ada_verona/database/epsilon_status.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"Convert the EpsilonStatus to a dictionary.\"\"\"\n    obtained_labels_value = None\n    if self.obtained_labels is not None:\n        if isinstance(self.obtained_labels, np.ndarray):\n            obtained_labels_value = self.obtained_labels.flatten().tolist()\n        elif isinstance(self.obtained_labels, list):\n            obtained_labels_value = self.obtained_labels\n        else:\n            obtained_labels_value = [self.obtained_labels]\n\n    return dict(\n        epsilon_value=self.value,\n        result=self.result,\n        time=self.time,\n        verifier=self.verifier,\n        obtained_labels=obtained_labels_value,\n    )\n</code></pre>"},{"location":"api/#ada_verona.EpsilonValueEstimator","title":"<code>EpsilonValueEstimator</code>","text":"<p>               Bases: <code>ABC</code></p> <p>An abstract base class for estimating epsilon values.</p> Source code in <code>ada_verona/epsilon_value_estimator/epsilon_value_estimator.py</code> <pre><code>class EpsilonValueEstimator(ABC):\n    \"\"\"\n    An abstract base class for estimating epsilon values.\n    \"\"\"\n\n    def __init__(self, epsilon_value_list: list[float], verifier: VerificationModule) -&gt; None:\n        \"\"\"\n        Initialize the EpsilonValueEstimator with the given epsilon value list and verifier.\n\n        Args:\n            epsilon_value_list (list[float]): The list of epsilon values to estimate.\n            verifier (VerificationModule): The verifier to use for verification.\n        \"\"\"\n        self.epsilon_value_list = epsilon_value_list\n        self.verifier = verifier\n\n    @abstractmethod\n    def compute_epsilon_value(self, verification_context: VerificationContext) -&gt; EpsilonValueResult:\n        \"\"\"\n        Compute the epsilon value for the given verification context.\n\n        Args:\n            verification_context (VerificationContext): The context for verification.\n\n        Returns:\n            EpsilonValueResult: The result of the epsilon value estimation.\n        \"\"\"\n        raise NotImplementedError(\"This is an abstract method and should be implemented in subclasses.\")\n</code></pre>"},{"location":"api/#ada_verona.EpsilonValueEstimator.__init__","title":"<code>__init__(epsilon_value_list, verifier)</code>","text":"<p>Initialize the EpsilonValueEstimator with the given epsilon value list and verifier.</p> <p>Parameters:</p> Name Type Description Default <code>epsilon_value_list</code> <code>list[float]</code> <p>The list of epsilon values to estimate.</p> required <code>verifier</code> <code>VerificationModule</code> <p>The verifier to use for verification.</p> required Source code in <code>ada_verona/epsilon_value_estimator/epsilon_value_estimator.py</code> <pre><code>def __init__(self, epsilon_value_list: list[float], verifier: VerificationModule) -&gt; None:\n    \"\"\"\n    Initialize the EpsilonValueEstimator with the given epsilon value list and verifier.\n\n    Args:\n        epsilon_value_list (list[float]): The list of epsilon values to estimate.\n        verifier (VerificationModule): The verifier to use for verification.\n    \"\"\"\n    self.epsilon_value_list = epsilon_value_list\n    self.verifier = verifier\n</code></pre>"},{"location":"api/#ada_verona.EpsilonValueEstimator.compute_epsilon_value","title":"<code>compute_epsilon_value(verification_context)</code>  <code>abstractmethod</code>","text":"<p>Compute the epsilon value for the given verification context.</p> <p>Parameters:</p> Name Type Description Default <code>verification_context</code> <code>VerificationContext</code> <p>The context for verification.</p> required <p>Returns:</p> Name Type Description <code>EpsilonValueResult</code> <code>EpsilonValueResult</code> <p>The result of the epsilon value estimation.</p> Source code in <code>ada_verona/epsilon_value_estimator/epsilon_value_estimator.py</code> <pre><code>@abstractmethod\ndef compute_epsilon_value(self, verification_context: VerificationContext) -&gt; EpsilonValueResult:\n    \"\"\"\n    Compute the epsilon value for the given verification context.\n\n    Args:\n        verification_context (VerificationContext): The context for verification.\n\n    Returns:\n        EpsilonValueResult: The result of the epsilon value estimation.\n    \"\"\"\n    raise NotImplementedError(\"This is an abstract method and should be implemented in subclasses.\")\n</code></pre>"},{"location":"api/#ada_verona.EpsilonValueResult","title":"<code>EpsilonValueResult</code>  <code>dataclass</code>","text":"<p>A dataclass defining the verification result of a single verification.</p> Source code in <code>ada_verona/database/epsilon_value_result.py</code> <pre><code>@dataclass\nclass EpsilonValueResult:\n    \"\"\"\n    A dataclass defining the verification result of a single verification.\n    \"\"\"\n\n    verification_context: VerificationContext\n    epsilon: float\n    smallest_sat_value: float\n    time: float = None\n    verifier: str = None\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"\n        Convert the EpsilonValueResult to a dictionary.\n\n        Returns:\n            dict: The dictionary representation of the EpsilonValueResult.\n        \"\"\"\n        ret = dict(\n            **self.verification_context.get_dict_for_epsilon_result(),\n            epsilon_value=self.epsilon,\n            smallest_sat_value=self.smallest_sat_value,\n            total_time=self.time,\n            verifier=self.verifier,\n        )\n        return ret\n</code></pre>"},{"location":"api/#ada_verona.EpsilonValueResult.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert the EpsilonValueResult to a dictionary.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The dictionary representation of the EpsilonValueResult.</p> Source code in <code>ada_verona/database/epsilon_value_result.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"\n    Convert the EpsilonValueResult to a dictionary.\n\n    Returns:\n        dict: The dictionary representation of the EpsilonValueResult.\n    \"\"\"\n    ret = dict(\n        **self.verification_context.get_dict_for_epsilon_result(),\n        epsilon_value=self.epsilon,\n        smallest_sat_value=self.smallest_sat_value,\n        total_time=self.time,\n        verifier=self.verifier,\n    )\n    return ret\n</code></pre>"},{"location":"api/#ada_verona.ExperimentRepository","title":"<code>ExperimentRepository</code>","text":"<p>Database to handle all the paths to the different files used.</p> Source code in <code>ada_verona/database/experiment_repository.py</code> <pre><code>class ExperimentRepository:\n    \"\"\"\n    Database to handle all the paths to the different files used.\n    \"\"\"\n\n    def __init__(self, base_path: Path, network_folder: Path) -&gt; None:\n        \"\"\"\n        Initialize the ExperimentRepository with the base path and network folder.\n\n        Args:\n            base_path (Path): The base path for the experiment repository.\n            network_folder (Path): The folder containing the network files.\n        \"\"\"\n        self.act_experiment_path = None\n        self.base_path = base_path\n        self.network_folder = network_folder\n\n    def get_act_experiment_path(self) -&gt; Path:\n        \"\"\"\n        Get the path to the active experiment.\n\n        Returns:\n            Path: The path to the active experiment.\n\n        Raises:\n            Exception: If no experiment is loaded.\n        \"\"\"\n        if self.act_experiment_path is not None:\n            return self.act_experiment_path\n        else:\n            raise Exception(\"No experiment loaded\")\n\n    def get_results_path(self) -&gt; Path:\n        \"\"\"\n        Get the path to the results folder of the active experiment.\n\n        Returns:\n            Path: The path to the results folder.\n        \"\"\"\n        return self.get_act_experiment_path() / \"results\"\n\n    def get_tmp_path(self) -&gt; Path:\n        \"\"\"\n        Get the path to the temporary folder of the active experiment.\n\n        Returns:\n            Path: The path to the temporary folder.\n        \"\"\"\n        return self.get_act_experiment_path() / \"tmp\"\n\n    def initialize_new_experiment(self, experiment_name: str) -&gt; None:\n        \"\"\"\n        Initialize a new experiment with the given name.\n\n        Args:\n            experiment_name (str): The name of the experiment.\n\n        Raises:\n            Exception: If a directory with the same name already exists.\n        \"\"\"\n        now = datetime.now()\n        now_string = now.strftime(\"%d-%m-%Y+%H_%M\")\n\n        self.act_experiment_path = self.base_path / f\"{experiment_name}_{now_string}\"\n\n        if os.path.exists(self.get_results_path()):\n            raise Exception(\n                \"Error, there is already a directory with results with the same name,\"\n                \"make sure no results will be overwritten\"  \n            )\n        else:\n            os.makedirs(self.get_results_path())\n        os.makedirs(self.get_tmp_path())\n\n    def load_experiment(self, experiment_name: str) -&gt; None:\n        \"\"\"\n        Load an existing experiment with the given name.\n\n        Args:\n            experiment_name (str): The name of the experiment.\n        \"\"\"\n        self.act_experiment_path = self.base_path / experiment_name\n\n    def save_configuration(self, data: dict) -&gt; None:\n        \"\"\"\n        Save the configuration data to a JSON file.\n\n        Args:\n            data (dict): The configuration data to save.\n        \"\"\"\n        with open(self.get_act_experiment_path() / \"configuration.json\", \"w\") as outfile:\n            json.dump(data, outfile)\n\n    def get_network_list(self) -&gt; list[ONNXNetwork]:\n        \"\"\"\n        Return a list of networks by scanning\n        the network folder for ONNX files if a network folder is given.\n\n        Returns:\n            list[Network]: The list of networks.\n        \"\"\"\n        if self.network_folder is None:\n            raise Exception(\"No Network folder given.\")\n        else:\n            network_path_list = [\n                file for file in self.network_folder.iterdir() \n                if file.is_file() and file.suffix.lower() == '.onnx'\n                ]\n            network_list = [ONNXNetwork(x) for x in network_path_list]\n        return network_list\n\n    def save_results(self, results: list[EpsilonValueResult]) -&gt; None:\n        \"\"\"\n        Save the list of epsilon value results to a CSV file.\n\n        Args:\n            results (list[EpsilonValueResult]): The list of epsilon value results to save.\n        \"\"\"\n        result_df = pd.DataFrame([x.to_dict() for x in results])\n        result_df.to_csv(self.get_results_path() / DEFAULT_RESULT_CSV_NAME)\n\n    def save_result(self, result: EpsilonValueResult) -&gt; None:\n        \"\"\"\n        Save a single epsilon value result to the CSV file.\n\n        Args:\n            result (EpsilonValueResult): The epsilon value result to save.\n        \"\"\"\n        result_df_path = self.get_results_path() / DEFAULT_RESULT_CSV_NAME\n        if result_df_path.exists():\n            df = pd.read_csv(result_df_path, index_col=0)\n            df.loc[len(df.index)] = result.to_dict()\n        else:\n            df = pd.DataFrame([result.to_dict()])\n        df.to_csv(result_df_path)\n\n    def get_file_name(self, file: Path) -&gt; str:\n        \"\"\"\n        Get the name of the file without the extension.\n\n        Args:\n            file (Path): The file path.\n\n        Returns:\n            str: The name of the file without the extension.\n        \"\"\"\n        return file.name.split(\".\")[0]\n\n    def create_verification_context(\n        self, network: Network, data_point: DataPoint, property_generator: PropertyGenerator\n    ) -&gt; VerificationContext:\n        \"\"\"\n        Create a verification context for the given network, data point, and property generator.\n\n        Args:\n            network (Network): The network to verify.\n            data_point (DataPoint): The data point to verify.\n            property_generator (PropertyGenerator): The property generator to use.\n\n        Returns:\n            VerificationContext: The created verification context.\n        \"\"\"\n        tmp_path = self.get_tmp_path() / f\"{network.name}\" / f\"image_{data_point.id}\"\n        return VerificationContext(network, data_point, tmp_path, property_generator)\n\n    def get_result_df(self) -&gt; pd.DataFrame:\n        \"\"\"\n        Get the result DataFrame from the results CSV file.\n\n        Returns:\n            pd.DataFrame: The result DataFrame.\n\n        Raises:\n            Exception: If no result file is found.\n        \"\"\"\n        result_df_path = self.get_results_path() / DEFAULT_RESULT_CSV_NAME\n        if result_df_path.exists():\n            df = pd.read_csv(result_df_path, index_col=0)\n            df[\"network\"] = df.network_path.str.split(\"/\").apply(lambda x: x[-1]).apply(lambda x: x.split(\".\")[0])\n\n            return df\n        else:\n            raise Exception(f\"Error, no result file found at {result_df_path}\")\n\n    def get_per_epsilon_result_df(self) -&gt; pd.DataFrame:\n        \"\"\"\n        Get the per-epsilon result DataFrame from the temporary folder.\n\n        Returns:\n            pd.DataFrame: The per-epsilon result DataFrame.\n        \"\"\"\n        per_epsilon_result_df_name = \"epsilons_df.csv\"\n        df = pd.DataFrame()\n        network_folders = [x for x in self.get_tmp_path().iterdir()]\n        for network_folder in network_folders:\n            images_folders = [x for x in network_folders[0].iterdir()]\n            for image_folder in images_folders:\n                t_df = pd.read_csv(image_folder / per_epsilon_result_df_name, index_col=0)\n                t_df[\"network\"] = network_folder.name\n                t_df[\"image\"] = image_folder.name\n                df = pd.concat([df, t_df])\n        return df\n\n    def save_per_epsilon_result_df(self) -&gt; None:\n        \"\"\"\n        Save the per-epsilon result DataFrame to a CSV file.\n        \"\"\"\n        per_epsilon_result_df = self.get_per_epsilon_result_df()\n        per_epsilon_result_df.to_csv(self.get_results_path() / PER_EPSILON_RESULT_CSV_NAME)\n\n    def save_plots(self) -&gt; None:\n        \"\"\"\n        Save the plots generated from the result DataFrame.\n        \"\"\"\n        df = self.get_result_df()\n        report_creator = ReportCreator(df)\n        hist_figure = report_creator.create_hist_figure()\n        hist_figure.savefig(self.get_results_path() / \"hist_figure.png\", bbox_inches=\"tight\")\n\n        boxplot = report_creator.create_box_figure()\n        boxplot.savefig(self.get_results_path() / \"boxplot.png\", bbox_inches=\"tight\")\n\n        kde_figure = report_creator.create_kde_figure()\n        kde_figure.savefig(self.get_results_path() / \"kde_plot.png\", bbox_inches=\"tight\")\n\n        ecdf_figure = report_creator.create_ecdf_figure()\n        ecdf_figure.savefig(self.get_results_path() / \"ecdf_plot.png\", bbox_inches=\"tight\")\n\n    def save_verification_context_to_yaml(self, file_path: Path, verification_context: VerificationContext) -&gt; Path:\n        \"\"\"\n        Save the verification context to a YAML file.\n\n        Args:\n            file_path (Path): The path to save the YAML file.\n            verification_context (VerificationContext): The verification context to save.\n\n        Returns:\n            Path: The path to the saved YAML file.\n        \"\"\"\n        with open(file_path, \"w\") as file:\n            yaml.dump(verification_context.to_dict(), file)\n        return file_path\n\n    def load_verification_context_from_yaml(self, file_path: Path) -&gt; VerificationContext:\n        \"\"\"\n        Load the verification context from a YAML file.\n\n        Args:\n            file_path (Path): The path to the YAML file.\n\n        Returns:\n            VerificationContext: The loaded verification context.\n        \"\"\"\n        with open(file_path) as file:\n            data = yaml.safe_load(file)\n            return VerificationContext.from_dict(data)\n\n    def cleanup_tmp_directory(self):\n        \"\"\"\n        Delete the temporary folder of the active experiment.\n        \"\"\"\n\n        tmp_path = self.get_tmp_path()\n        if tmp_path.exists():\n            for file in tmp_path.iterdir():\n                file.unlink()\n            tmp_path.rmdir()\n</code></pre>"},{"location":"api/#ada_verona.ExperimentRepository.__init__","title":"<code>__init__(base_path, network_folder)</code>","text":"<p>Initialize the ExperimentRepository with the base path and network folder.</p> <p>Parameters:</p> Name Type Description Default <code>base_path</code> <code>Path</code> <p>The base path for the experiment repository.</p> required <code>network_folder</code> <code>Path</code> <p>The folder containing the network files.</p> required Source code in <code>ada_verona/database/experiment_repository.py</code> <pre><code>def __init__(self, base_path: Path, network_folder: Path) -&gt; None:\n    \"\"\"\n    Initialize the ExperimentRepository with the base path and network folder.\n\n    Args:\n        base_path (Path): The base path for the experiment repository.\n        network_folder (Path): The folder containing the network files.\n    \"\"\"\n    self.act_experiment_path = None\n    self.base_path = base_path\n    self.network_folder = network_folder\n</code></pre>"},{"location":"api/#ada_verona.ExperimentRepository.cleanup_tmp_directory","title":"<code>cleanup_tmp_directory()</code>","text":"<p>Delete the temporary folder of the active experiment.</p> Source code in <code>ada_verona/database/experiment_repository.py</code> <pre><code>def cleanup_tmp_directory(self):\n    \"\"\"\n    Delete the temporary folder of the active experiment.\n    \"\"\"\n\n    tmp_path = self.get_tmp_path()\n    if tmp_path.exists():\n        for file in tmp_path.iterdir():\n            file.unlink()\n        tmp_path.rmdir()\n</code></pre>"},{"location":"api/#ada_verona.ExperimentRepository.create_verification_context","title":"<code>create_verification_context(network, data_point, property_generator)</code>","text":"<p>Create a verification context for the given network, data point, and property generator.</p> <p>Parameters:</p> Name Type Description Default <code>network</code> <code>Network</code> <p>The network to verify.</p> required <code>data_point</code> <code>DataPoint</code> <p>The data point to verify.</p> required <code>property_generator</code> <code>PropertyGenerator</code> <p>The property generator to use.</p> required <p>Returns:</p> Name Type Description <code>VerificationContext</code> <code>VerificationContext</code> <p>The created verification context.</p> Source code in <code>ada_verona/database/experiment_repository.py</code> <pre><code>def create_verification_context(\n    self, network: Network, data_point: DataPoint, property_generator: PropertyGenerator\n) -&gt; VerificationContext:\n    \"\"\"\n    Create a verification context for the given network, data point, and property generator.\n\n    Args:\n        network (Network): The network to verify.\n        data_point (DataPoint): The data point to verify.\n        property_generator (PropertyGenerator): The property generator to use.\n\n    Returns:\n        VerificationContext: The created verification context.\n    \"\"\"\n    tmp_path = self.get_tmp_path() / f\"{network.name}\" / f\"image_{data_point.id}\"\n    return VerificationContext(network, data_point, tmp_path, property_generator)\n</code></pre>"},{"location":"api/#ada_verona.ExperimentRepository.get_act_experiment_path","title":"<code>get_act_experiment_path()</code>","text":"<p>Get the path to the active experiment.</p> <p>Returns:</p> Name Type Description <code>Path</code> <code>Path</code> <p>The path to the active experiment.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If no experiment is loaded.</p> Source code in <code>ada_verona/database/experiment_repository.py</code> <pre><code>def get_act_experiment_path(self) -&gt; Path:\n    \"\"\"\n    Get the path to the active experiment.\n\n    Returns:\n        Path: The path to the active experiment.\n\n    Raises:\n        Exception: If no experiment is loaded.\n    \"\"\"\n    if self.act_experiment_path is not None:\n        return self.act_experiment_path\n    else:\n        raise Exception(\"No experiment loaded\")\n</code></pre>"},{"location":"api/#ada_verona.ExperimentRepository.get_file_name","title":"<code>get_file_name(file)</code>","text":"<p>Get the name of the file without the extension.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>Path</code> <p>The file path.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The name of the file without the extension.</p> Source code in <code>ada_verona/database/experiment_repository.py</code> <pre><code>def get_file_name(self, file: Path) -&gt; str:\n    \"\"\"\n    Get the name of the file without the extension.\n\n    Args:\n        file (Path): The file path.\n\n    Returns:\n        str: The name of the file without the extension.\n    \"\"\"\n    return file.name.split(\".\")[0]\n</code></pre>"},{"location":"api/#ada_verona.ExperimentRepository.get_network_list","title":"<code>get_network_list()</code>","text":"<p>Return a list of networks by scanning the network folder for ONNX files if a network folder is given.</p> <p>Returns:</p> Type Description <code>list[ONNXNetwork]</code> <p>list[Network]: The list of networks.</p> Source code in <code>ada_verona/database/experiment_repository.py</code> <pre><code>def get_network_list(self) -&gt; list[ONNXNetwork]:\n    \"\"\"\n    Return a list of networks by scanning\n    the network folder for ONNX files if a network folder is given.\n\n    Returns:\n        list[Network]: The list of networks.\n    \"\"\"\n    if self.network_folder is None:\n        raise Exception(\"No Network folder given.\")\n    else:\n        network_path_list = [\n            file for file in self.network_folder.iterdir() \n            if file.is_file() and file.suffix.lower() == '.onnx'\n            ]\n        network_list = [ONNXNetwork(x) for x in network_path_list]\n    return network_list\n</code></pre>"},{"location":"api/#ada_verona.ExperimentRepository.get_per_epsilon_result_df","title":"<code>get_per_epsilon_result_df()</code>","text":"<p>Get the per-epsilon result DataFrame from the temporary folder.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: The per-epsilon result DataFrame.</p> Source code in <code>ada_verona/database/experiment_repository.py</code> <pre><code>def get_per_epsilon_result_df(self) -&gt; pd.DataFrame:\n    \"\"\"\n    Get the per-epsilon result DataFrame from the temporary folder.\n\n    Returns:\n        pd.DataFrame: The per-epsilon result DataFrame.\n    \"\"\"\n    per_epsilon_result_df_name = \"epsilons_df.csv\"\n    df = pd.DataFrame()\n    network_folders = [x for x in self.get_tmp_path().iterdir()]\n    for network_folder in network_folders:\n        images_folders = [x for x in network_folders[0].iterdir()]\n        for image_folder in images_folders:\n            t_df = pd.read_csv(image_folder / per_epsilon_result_df_name, index_col=0)\n            t_df[\"network\"] = network_folder.name\n            t_df[\"image\"] = image_folder.name\n            df = pd.concat([df, t_df])\n    return df\n</code></pre>"},{"location":"api/#ada_verona.ExperimentRepository.get_result_df","title":"<code>get_result_df()</code>","text":"<p>Get the result DataFrame from the results CSV file.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: The result DataFrame.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If no result file is found.</p> Source code in <code>ada_verona/database/experiment_repository.py</code> <pre><code>def get_result_df(self) -&gt; pd.DataFrame:\n    \"\"\"\n    Get the result DataFrame from the results CSV file.\n\n    Returns:\n        pd.DataFrame: The result DataFrame.\n\n    Raises:\n        Exception: If no result file is found.\n    \"\"\"\n    result_df_path = self.get_results_path() / DEFAULT_RESULT_CSV_NAME\n    if result_df_path.exists():\n        df = pd.read_csv(result_df_path, index_col=0)\n        df[\"network\"] = df.network_path.str.split(\"/\").apply(lambda x: x[-1]).apply(lambda x: x.split(\".\")[0])\n\n        return df\n    else:\n        raise Exception(f\"Error, no result file found at {result_df_path}\")\n</code></pre>"},{"location":"api/#ada_verona.ExperimentRepository.get_results_path","title":"<code>get_results_path()</code>","text":"<p>Get the path to the results folder of the active experiment.</p> <p>Returns:</p> Name Type Description <code>Path</code> <code>Path</code> <p>The path to the results folder.</p> Source code in <code>ada_verona/database/experiment_repository.py</code> <pre><code>def get_results_path(self) -&gt; Path:\n    \"\"\"\n    Get the path to the results folder of the active experiment.\n\n    Returns:\n        Path: The path to the results folder.\n    \"\"\"\n    return self.get_act_experiment_path() / \"results\"\n</code></pre>"},{"location":"api/#ada_verona.ExperimentRepository.get_tmp_path","title":"<code>get_tmp_path()</code>","text":"<p>Get the path to the temporary folder of the active experiment.</p> <p>Returns:</p> Name Type Description <code>Path</code> <code>Path</code> <p>The path to the temporary folder.</p> Source code in <code>ada_verona/database/experiment_repository.py</code> <pre><code>def get_tmp_path(self) -&gt; Path:\n    \"\"\"\n    Get the path to the temporary folder of the active experiment.\n\n    Returns:\n        Path: The path to the temporary folder.\n    \"\"\"\n    return self.get_act_experiment_path() / \"tmp\"\n</code></pre>"},{"location":"api/#ada_verona.ExperimentRepository.initialize_new_experiment","title":"<code>initialize_new_experiment(experiment_name)</code>","text":"<p>Initialize a new experiment with the given name.</p> <p>Parameters:</p> Name Type Description Default <code>experiment_name</code> <code>str</code> <p>The name of the experiment.</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>If a directory with the same name already exists.</p> Source code in <code>ada_verona/database/experiment_repository.py</code> <pre><code>def initialize_new_experiment(self, experiment_name: str) -&gt; None:\n    \"\"\"\n    Initialize a new experiment with the given name.\n\n    Args:\n        experiment_name (str): The name of the experiment.\n\n    Raises:\n        Exception: If a directory with the same name already exists.\n    \"\"\"\n    now = datetime.now()\n    now_string = now.strftime(\"%d-%m-%Y+%H_%M\")\n\n    self.act_experiment_path = self.base_path / f\"{experiment_name}_{now_string}\"\n\n    if os.path.exists(self.get_results_path()):\n        raise Exception(\n            \"Error, there is already a directory with results with the same name,\"\n            \"make sure no results will be overwritten\"  \n        )\n    else:\n        os.makedirs(self.get_results_path())\n    os.makedirs(self.get_tmp_path())\n</code></pre>"},{"location":"api/#ada_verona.ExperimentRepository.load_experiment","title":"<code>load_experiment(experiment_name)</code>","text":"<p>Load an existing experiment with the given name.</p> <p>Parameters:</p> Name Type Description Default <code>experiment_name</code> <code>str</code> <p>The name of the experiment.</p> required Source code in <code>ada_verona/database/experiment_repository.py</code> <pre><code>def load_experiment(self, experiment_name: str) -&gt; None:\n    \"\"\"\n    Load an existing experiment with the given name.\n\n    Args:\n        experiment_name (str): The name of the experiment.\n    \"\"\"\n    self.act_experiment_path = self.base_path / experiment_name\n</code></pre>"},{"location":"api/#ada_verona.ExperimentRepository.load_verification_context_from_yaml","title":"<code>load_verification_context_from_yaml(file_path)</code>","text":"<p>Load the verification context from a YAML file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Path</code> <p>The path to the YAML file.</p> required <p>Returns:</p> Name Type Description <code>VerificationContext</code> <code>VerificationContext</code> <p>The loaded verification context.</p> Source code in <code>ada_verona/database/experiment_repository.py</code> <pre><code>def load_verification_context_from_yaml(self, file_path: Path) -&gt; VerificationContext:\n    \"\"\"\n    Load the verification context from a YAML file.\n\n    Args:\n        file_path (Path): The path to the YAML file.\n\n    Returns:\n        VerificationContext: The loaded verification context.\n    \"\"\"\n    with open(file_path) as file:\n        data = yaml.safe_load(file)\n        return VerificationContext.from_dict(data)\n</code></pre>"},{"location":"api/#ada_verona.ExperimentRepository.save_configuration","title":"<code>save_configuration(data)</code>","text":"<p>Save the configuration data to a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>The configuration data to save.</p> required Source code in <code>ada_verona/database/experiment_repository.py</code> <pre><code>def save_configuration(self, data: dict) -&gt; None:\n    \"\"\"\n    Save the configuration data to a JSON file.\n\n    Args:\n        data (dict): The configuration data to save.\n    \"\"\"\n    with open(self.get_act_experiment_path() / \"configuration.json\", \"w\") as outfile:\n        json.dump(data, outfile)\n</code></pre>"},{"location":"api/#ada_verona.ExperimentRepository.save_per_epsilon_result_df","title":"<code>save_per_epsilon_result_df()</code>","text":"<p>Save the per-epsilon result DataFrame to a CSV file.</p> Source code in <code>ada_verona/database/experiment_repository.py</code> <pre><code>def save_per_epsilon_result_df(self) -&gt; None:\n    \"\"\"\n    Save the per-epsilon result DataFrame to a CSV file.\n    \"\"\"\n    per_epsilon_result_df = self.get_per_epsilon_result_df()\n    per_epsilon_result_df.to_csv(self.get_results_path() / PER_EPSILON_RESULT_CSV_NAME)\n</code></pre>"},{"location":"api/#ada_verona.ExperimentRepository.save_plots","title":"<code>save_plots()</code>","text":"<p>Save the plots generated from the result DataFrame.</p> Source code in <code>ada_verona/database/experiment_repository.py</code> <pre><code>def save_plots(self) -&gt; None:\n    \"\"\"\n    Save the plots generated from the result DataFrame.\n    \"\"\"\n    df = self.get_result_df()\n    report_creator = ReportCreator(df)\n    hist_figure = report_creator.create_hist_figure()\n    hist_figure.savefig(self.get_results_path() / \"hist_figure.png\", bbox_inches=\"tight\")\n\n    boxplot = report_creator.create_box_figure()\n    boxplot.savefig(self.get_results_path() / \"boxplot.png\", bbox_inches=\"tight\")\n\n    kde_figure = report_creator.create_kde_figure()\n    kde_figure.savefig(self.get_results_path() / \"kde_plot.png\", bbox_inches=\"tight\")\n\n    ecdf_figure = report_creator.create_ecdf_figure()\n    ecdf_figure.savefig(self.get_results_path() / \"ecdf_plot.png\", bbox_inches=\"tight\")\n</code></pre>"},{"location":"api/#ada_verona.ExperimentRepository.save_result","title":"<code>save_result(result)</code>","text":"<p>Save a single epsilon value result to the CSV file.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>EpsilonValueResult</code> <p>The epsilon value result to save.</p> required Source code in <code>ada_verona/database/experiment_repository.py</code> <pre><code>def save_result(self, result: EpsilonValueResult) -&gt; None:\n    \"\"\"\n    Save a single epsilon value result to the CSV file.\n\n    Args:\n        result (EpsilonValueResult): The epsilon value result to save.\n    \"\"\"\n    result_df_path = self.get_results_path() / DEFAULT_RESULT_CSV_NAME\n    if result_df_path.exists():\n        df = pd.read_csv(result_df_path, index_col=0)\n        df.loc[len(df.index)] = result.to_dict()\n    else:\n        df = pd.DataFrame([result.to_dict()])\n    df.to_csv(result_df_path)\n</code></pre>"},{"location":"api/#ada_verona.ExperimentRepository.save_results","title":"<code>save_results(results)</code>","text":"<p>Save the list of epsilon value results to a CSV file.</p> <p>Parameters:</p> Name Type Description Default <code>results</code> <code>list[EpsilonValueResult]</code> <p>The list of epsilon value results to save.</p> required Source code in <code>ada_verona/database/experiment_repository.py</code> <pre><code>def save_results(self, results: list[EpsilonValueResult]) -&gt; None:\n    \"\"\"\n    Save the list of epsilon value results to a CSV file.\n\n    Args:\n        results (list[EpsilonValueResult]): The list of epsilon value results to save.\n    \"\"\"\n    result_df = pd.DataFrame([x.to_dict() for x in results])\n    result_df.to_csv(self.get_results_path() / DEFAULT_RESULT_CSV_NAME)\n</code></pre>"},{"location":"api/#ada_verona.ExperimentRepository.save_verification_context_to_yaml","title":"<code>save_verification_context_to_yaml(file_path, verification_context)</code>","text":"<p>Save the verification context to a YAML file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Path</code> <p>The path to save the YAML file.</p> required <code>verification_context</code> <code>VerificationContext</code> <p>The verification context to save.</p> required <p>Returns:</p> Name Type Description <code>Path</code> <code>Path</code> <p>The path to the saved YAML file.</p> Source code in <code>ada_verona/database/experiment_repository.py</code> <pre><code>def save_verification_context_to_yaml(self, file_path: Path, verification_context: VerificationContext) -&gt; Path:\n    \"\"\"\n    Save the verification context to a YAML file.\n\n    Args:\n        file_path (Path): The path to save the YAML file.\n        verification_context (VerificationContext): The verification context to save.\n\n    Returns:\n        Path: The path to the saved YAML file.\n    \"\"\"\n    with open(file_path, \"w\") as file:\n        yaml.dump(verification_context.to_dict(), file)\n    return file_path\n</code></pre>"},{"location":"api/#ada_verona.IterativeEpsilonValueEstimator","title":"<code>IterativeEpsilonValueEstimator</code>","text":"<p>               Bases: <code>EpsilonValueEstimator</code></p> <p>A class to estimate the epsilon value using an iterative search with configurable direction.</p> Source code in <code>ada_verona/epsilon_value_estimator/iterative_epsilon_value_estimator.py</code> <pre><code>class IterativeEpsilonValueEstimator(EpsilonValueEstimator):\n    \"\"\"\n    A class to estimate the epsilon value using an iterative search with configurable direction.\n    \"\"\"\n    def compute_epsilon_value(\n    self,\n    verification_context: VerificationContext,\n    reverse_search=False,\n) -&gt; EpsilonValueResult:\n        \"\"\"\n        Compute the epsilon value using an iterative search.\n\n        Args:\n            verification_context (VerificationContext): The context for verification.\n\n        Returns:\n            EpsilonValueResult: The result of the epsilon value estimation.\n        \"\"\"\n        sorted_epsilons = sorted(self.epsilon_value_list, reverse=reverse_search)\n        epsilon_status_list = [EpsilonStatus(x, None, None, self.verifier.name) for x in sorted_epsilons]\n        start_time = time.time()\n        highest_unsat_value, lowest_sat_value, epsilon_status_list = self.iterative_search(\n            verification_context, epsilon_status_list\n        )\n        duration = time.time() - start_time\n        epsilon_value_result = EpsilonValueResult(verification_context, \n                                                  highest_unsat_value, \n                                                  lowest_sat_value, \n                                                  duration, \n                                                  self.verifier.name)\n\n        return epsilon_value_result\n\n    def iterative_search(self, \n                         verification_context: VerificationContext, \n                        epsilon_status_list: list[EpsilonStatus]) -&gt; tuple[float, float, list]:\n        \"\"\"\n        Perform search and determine results based on actual epsilon values. \n        Find the highest UNSAT and smallest SAT epsilon values.\n\n        Args:\n            verification_context (VerificationContext): The context for verification.\n            epsilon_status_list (list[EpsilonStatus]): The list of epsilon statuses.\n\n        Returns:\n            float: The highest UNSAT epsilon value.\n            float: The smallest SAT epsilon value.\n            list: The epsilon status list.\n        \"\"\"\n\n        for status in epsilon_status_list:\n            outcome = self.verifier.verify(verification_context, status.value)\n            status.set_values(outcome)\n            verification_context.save_result(status)\n            logger.info(f\"epsilon value: {status.value}, result: {status.result}\")\n\n        unsat_values = [x.value for x in epsilon_status_list if x.result == VerificationResult.UNSAT]\n        sat_values = [x.value for x in epsilon_status_list if x.result == VerificationResult.SAT]\n\n        highest_unsat = max(unsat_values) if unsat_values else 0\n        lowest_sat = min(sat_values) if sat_values else 'undefined'\n\n\n        return highest_unsat, lowest_sat, epsilon_status_list\n</code></pre>"},{"location":"api/#ada_verona.IterativeEpsilonValueEstimator.compute_epsilon_value","title":"<code>compute_epsilon_value(verification_context, reverse_search=False)</code>","text":"<p>Compute the epsilon value using an iterative search.</p> <p>Parameters:</p> Name Type Description Default <code>verification_context</code> <code>VerificationContext</code> <p>The context for verification.</p> required <p>Returns:</p> Name Type Description <code>EpsilonValueResult</code> <code>EpsilonValueResult</code> <p>The result of the epsilon value estimation.</p> Source code in <code>ada_verona/epsilon_value_estimator/iterative_epsilon_value_estimator.py</code> <pre><code>    def compute_epsilon_value(\n    self,\n    verification_context: VerificationContext,\n    reverse_search=False,\n) -&gt; EpsilonValueResult:\n        \"\"\"\n        Compute the epsilon value using an iterative search.\n\n        Args:\n            verification_context (VerificationContext): The context for verification.\n\n        Returns:\n            EpsilonValueResult: The result of the epsilon value estimation.\n        \"\"\"\n        sorted_epsilons = sorted(self.epsilon_value_list, reverse=reverse_search)\n        epsilon_status_list = [EpsilonStatus(x, None, None, self.verifier.name) for x in sorted_epsilons]\n        start_time = time.time()\n        highest_unsat_value, lowest_sat_value, epsilon_status_list = self.iterative_search(\n            verification_context, epsilon_status_list\n        )\n        duration = time.time() - start_time\n        epsilon_value_result = EpsilonValueResult(verification_context, \n                                                  highest_unsat_value, \n                                                  lowest_sat_value, \n                                                  duration, \n                                                  self.verifier.name)\n\n        return epsilon_value_result\n</code></pre>"},{"location":"api/#ada_verona.IterativeEpsilonValueEstimator.iterative_search","title":"<code>iterative_search(verification_context, epsilon_status_list)</code>","text":"<p>Perform search and determine results based on actual epsilon values.  Find the highest UNSAT and smallest SAT epsilon values.</p> <p>Parameters:</p> Name Type Description Default <code>verification_context</code> <code>VerificationContext</code> <p>The context for verification.</p> required <code>epsilon_status_list</code> <code>list[EpsilonStatus]</code> <p>The list of epsilon statuses.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The highest UNSAT epsilon value.</p> <code>float</code> <code>float</code> <p>The smallest SAT epsilon value.</p> <code>list</code> <code>list</code> <p>The epsilon status list.</p> Source code in <code>ada_verona/epsilon_value_estimator/iterative_epsilon_value_estimator.py</code> <pre><code>def iterative_search(self, \n                     verification_context: VerificationContext, \n                    epsilon_status_list: list[EpsilonStatus]) -&gt; tuple[float, float, list]:\n    \"\"\"\n    Perform search and determine results based on actual epsilon values. \n    Find the highest UNSAT and smallest SAT epsilon values.\n\n    Args:\n        verification_context (VerificationContext): The context for verification.\n        epsilon_status_list (list[EpsilonStatus]): The list of epsilon statuses.\n\n    Returns:\n        float: The highest UNSAT epsilon value.\n        float: The smallest SAT epsilon value.\n        list: The epsilon status list.\n    \"\"\"\n\n    for status in epsilon_status_list:\n        outcome = self.verifier.verify(verification_context, status.value)\n        status.set_values(outcome)\n        verification_context.save_result(status)\n        logger.info(f\"epsilon value: {status.value}, result: {status.result}\")\n\n    unsat_values = [x.value for x in epsilon_status_list if x.result == VerificationResult.UNSAT]\n    sat_values = [x.value for x in epsilon_status_list if x.result == VerificationResult.SAT]\n\n    highest_unsat = max(unsat_values) if unsat_values else 0\n    lowest_sat = min(sat_values) if sat_values else 'undefined'\n\n\n    return highest_unsat, lowest_sat, epsilon_status_list\n</code></pre>"},{"location":"api/#ada_verona.Network","title":"<code>Network</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for networks that can be either ONNX or PyTorch.</p> <p>This class provides a common interface for both network types.</p> Source code in <code>ada_verona/database/machine_learning_model/network.py</code> <pre><code>class Network(ABC):\n    \"\"\"\n    Abstract base class for networks that can be either ONNX or PyTorch.\n\n    This class provides a common interface for both network types.\n    \"\"\"\n\n    @abstractmethod\n    def load_pytorch_model(self) -&gt; torch.nn.Module:\n        \"\"\"\n        Load the PyTorch model.\n\n        Returns:\n            torch.nn.Module: The loaded PyTorch model.\n        \"\"\"\n        raise NotImplementedError(\"This is an abstract method and should be implemented in subclasses.\")\n\n\n\n    @abstractmethod\n    def get_input_shape(self) -&gt; np.ndarray | tuple[int, ...]:\n        \"\"\"\n        Get the input shape of the model.\n\n        Returns:\n            Union[np.ndarray, tuple[int, ...]]: The input shape of the model.\n        \"\"\"\n        raise NotImplementedError(\"This is an abstract method and should be implemented in subclasses.\")\n\n\n\n    @abstractmethod\n    def to_dict(self) -&gt; dict:\n        \"\"\"\n        Convert the network to a dictionary.\n\n        Returns:\n            dict: The dictionary representation of the network.\n        \"\"\"\n        raise NotImplementedError(\"This is an abstract method and should be implemented in subclasses.\")\n\n\n\n    @classmethod\n    @abstractmethod\n    def from_dict(cls, data: dict) -&gt; \"Network\":\n        \"\"\"\n        Create a network from a dictionary.\n\n        Args:\n            data (dict): The dictionary containing the network attributes.\n\n        Returns:\n            BaseNetwork: The created network.\n        \"\"\"\n        raise NotImplementedError(\"This is an abstract method and should be implemented in subclasses.\")\n\n\n    @property\n    @abstractmethod\n    def name(self) -&gt; str:\n        \"\"\"\n        Get the name of the network.\n\n        Returns:\n            str: The name of the network.\n        \"\"\"\n        raise NotImplementedError(\"This is an abstract method and should be implemented in subclasses.\")\n\n    @property\n    @abstractmethod\n    def path(self) -&gt; Path:\n        \"\"\"\n        Get the path of the network.\n\n        Returns:\n            Path: The path of the network.\n        \"\"\"\n        raise NotImplementedError(\"This is an abstract method and should be implemented in subclasses.\")\n\n    @classmethod\n    def from_file(cls, file: dict[Path]):\n        \"\"\"Create network from file\n        Args: \n            file (dict[Path]): contains the paths to the relevant weights (for ONNX) \n            and additionally to the architecture file for PyTorch networks.\n\n        Returns: \n            Created network from the correct class OR error. \n        \"\"\"\n        raise NotImplementedError(\"This is an abstract method and should be implemented in subclasses.\")\n</code></pre>"},{"location":"api/#ada_verona.Network.name","title":"<code>name</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the name of the network.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The name of the network.</p>"},{"location":"api/#ada_verona.Network.path","title":"<code>path</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the path of the network.</p> <p>Returns:</p> Name Type Description <code>Path</code> <code>Path</code> <p>The path of the network.</p>"},{"location":"api/#ada_verona.Network.from_dict","title":"<code>from_dict(data)</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"<p>Create a network from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>The dictionary containing the network attributes.</p> required <p>Returns:</p> Name Type Description <code>BaseNetwork</code> <code>Network</code> <p>The created network.</p> Source code in <code>ada_verona/database/machine_learning_model/network.py</code> <pre><code>@classmethod\n@abstractmethod\ndef from_dict(cls, data: dict) -&gt; \"Network\":\n    \"\"\"\n    Create a network from a dictionary.\n\n    Args:\n        data (dict): The dictionary containing the network attributes.\n\n    Returns:\n        BaseNetwork: The created network.\n    \"\"\"\n    raise NotImplementedError(\"This is an abstract method and should be implemented in subclasses.\")\n</code></pre>"},{"location":"api/#ada_verona.Network.from_file","title":"<code>from_file(file)</code>  <code>classmethod</code>","text":"<p>Create network from file Args:      file (dict[Path]): contains the paths to the relevant weights (for ONNX)      and additionally to the architecture file for PyTorch networks.</p> <p>Returns:</p> Type Description <p>Created network from the correct class OR error.</p> Source code in <code>ada_verona/database/machine_learning_model/network.py</code> <pre><code>@classmethod\ndef from_file(cls, file: dict[Path]):\n    \"\"\"Create network from file\n    Args: \n        file (dict[Path]): contains the paths to the relevant weights (for ONNX) \n        and additionally to the architecture file for PyTorch networks.\n\n    Returns: \n        Created network from the correct class OR error. \n    \"\"\"\n    raise NotImplementedError(\"This is an abstract method and should be implemented in subclasses.\")\n</code></pre>"},{"location":"api/#ada_verona.Network.get_input_shape","title":"<code>get_input_shape()</code>  <code>abstractmethod</code>","text":"<p>Get the input shape of the model.</p> <p>Returns:</p> Type Description <code>ndarray | tuple[int, ...]</code> <p>Union[np.ndarray, tuple[int, ...]]: The input shape of the model.</p> Source code in <code>ada_verona/database/machine_learning_model/network.py</code> <pre><code>@abstractmethod\ndef get_input_shape(self) -&gt; np.ndarray | tuple[int, ...]:\n    \"\"\"\n    Get the input shape of the model.\n\n    Returns:\n        Union[np.ndarray, tuple[int, ...]]: The input shape of the model.\n    \"\"\"\n    raise NotImplementedError(\"This is an abstract method and should be implemented in subclasses.\")\n</code></pre>"},{"location":"api/#ada_verona.Network.load_pytorch_model","title":"<code>load_pytorch_model()</code>  <code>abstractmethod</code>","text":"<p>Load the PyTorch model.</p> <p>Returns:</p> Type Description <code>Module</code> <p>torch.nn.Module: The loaded PyTorch model.</p> Source code in <code>ada_verona/database/machine_learning_model/network.py</code> <pre><code>@abstractmethod\ndef load_pytorch_model(self) -&gt; torch.nn.Module:\n    \"\"\"\n    Load the PyTorch model.\n\n    Returns:\n        torch.nn.Module: The loaded PyTorch model.\n    \"\"\"\n    raise NotImplementedError(\"This is an abstract method and should be implemented in subclasses.\")\n</code></pre>"},{"location":"api/#ada_verona.Network.to_dict","title":"<code>to_dict()</code>  <code>abstractmethod</code>","text":"<p>Convert the network to a dictionary.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The dictionary representation of the network.</p> Source code in <code>ada_verona/database/machine_learning_model/network.py</code> <pre><code>@abstractmethod\ndef to_dict(self) -&gt; dict:\n    \"\"\"\n    Convert the network to a dictionary.\n\n    Returns:\n        dict: The dictionary representation of the network.\n    \"\"\"\n    raise NotImplementedError(\"This is an abstract method and should be implemented in subclasses.\")\n</code></pre>"},{"location":"api/#ada_verona.ONNXNetwork","title":"<code>ONNXNetwork</code>","text":"<p>               Bases: <code>Network</code></p> <p>Data class representing an ONNX network with its path.</p> <p>Attributes:</p> Name Type Description <code>path</code> <code>Path</code> <p>The path to the network file.</p> <code>onnx_model</code> <code>ModelProto</code> <p>The loaded ONNX model. Defaults to None.</p> <code>torch_model_wrapper</code> <code>TorchModelWrapper</code> <p>The PyTorch model wrapper. Defaults to None.</p> Source code in <code>ada_verona/database/machine_learning_model/onnx_network.py</code> <pre><code>class ONNXNetwork(Network):\n    \"\"\"\n    Data class representing an ONNX network with its path.\n\n    Attributes:\n        path (Path): The path to the network file.\n        onnx_model (onnx.ModelProto, optional): The loaded ONNX model. Defaults to None.\n        torch_model_wrapper (TorchModelWrapper, optional): The PyTorch model wrapper. Defaults to None.\n    \"\"\"\n\n    def __init__(self, path: Path) -&gt; None:\n        \"\"\"\n        Initialize the Network with the given path.\n\n        Args:\n            path (Path): The path to the network file.\n        \"\"\"\n        self._path = path\n        self.onnx_model = None\n        self.torch_model_wrapper = None\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"\n        Get the name of the network.\n\n        Returns:\n            str: The name of the network.\n        \"\"\"\n        return self.path.stem\n\n    @property\n    def path(self) -&gt; Path:\n        \"\"\"\n        Get the path of the network.\n\n        Returns:\n            Path: The path of the network.\n        \"\"\"\n        return self._path\n\n    def load_onnx_model(self) -&gt; onnx.ModelProto:\n        \"\"\"\n        Load the ONNX model from the network path.\n\n        Returns:\n            onnx.ModelProto: The loaded ONNX model.\n        \"\"\"\n        model = self.onnx_model\n        if model is None:\n            model = onnx.load(str(self.path))\n            self.onnx_model = model\n\n        return model\n\n    def get_input_shape(self) -&gt; np.ndarray:\n        \"\"\"\n        Get the input shape of the ONNX model.\n\n        Returns:\n            np.ndarray: The input shape of the ONNX model.\n        \"\"\"\n        model = self.load_onnx_model()\n        input_shape = tuple([d.dim_value for d in model.graph.input[0].type.tensor_type.shape.dim])\n        input_shape = [x if x != 0 else -1 for x in input_shape]\n\n        return input_shape\n\n    def load_pytorch_model(self) -&gt; torch.nn.Module:\n        \"\"\"\n        Load the PyTorch model from the ONNX model.\n\n        Returns:\n            torch.nn.Module: The loaded PyTorch model.\n        \"\"\"\n        device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n        torch_model_wrapper = self.torch_model_wrapper\n        if torch_model_wrapper is None:\n            torch_model = convert(self.path).to(device)\n            torch_model_wrapper = TorchModelWrapper(torch_model, self.get_input_shape())\n            self.torch_model_wrapper = torch_model_wrapper\n\n        return torch_model_wrapper\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"\n        Convert the Network to a dictionary.\n\n        Returns:\n            dict: The dictionary representation of the Network.\n        \"\"\"\n\n        return dict(network_path =  str(self.path), \n                type=self.__class__.__name__,\n                module=self.__class__.__module__,\n                    )\n\n    @classmethod\n    def from_dict(cls, data: dict)-&gt; \"ONNXNetwork\":\n        \"\"\"\n        Create a Network from a dictionary.\n\n        Args:\n            data (dict): The dictionary containing the Network attributes.\n\n        Returns:\n            Network: The created Network.\n        \"\"\"\n        return cls(path = data['network_path'])\n\n    @classmethod\n    def from_file(cls, file:Path)-&gt; \"ONNXNetwork\":\n        \"\"\"\n        Create a ONNXNetwork from a dictionary.\n\n        Args:\n            file (Path): Path at which the network is stored. \n\n        Returns:\n            ONNXNetwork: The created ONNXNetwork.\n        \"\"\"\n\n        if not file.is_file():\n            raise FileNotFoundError(f\"File not found: {file}\")\n\n        return cls(path = file)\n</code></pre>"},{"location":"api/#ada_verona.ONNXNetwork.name","title":"<code>name</code>  <code>property</code>","text":"<p>Get the name of the network.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The name of the network.</p>"},{"location":"api/#ada_verona.ONNXNetwork.path","title":"<code>path</code>  <code>property</code>","text":"<p>Get the path of the network.</p> <p>Returns:</p> Name Type Description <code>Path</code> <code>Path</code> <p>The path of the network.</p>"},{"location":"api/#ada_verona.ONNXNetwork.__init__","title":"<code>__init__(path)</code>","text":"<p>Initialize the Network with the given path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>The path to the network file.</p> required Source code in <code>ada_verona/database/machine_learning_model/onnx_network.py</code> <pre><code>def __init__(self, path: Path) -&gt; None:\n    \"\"\"\n    Initialize the Network with the given path.\n\n    Args:\n        path (Path): The path to the network file.\n    \"\"\"\n    self._path = path\n    self.onnx_model = None\n    self.torch_model_wrapper = None\n</code></pre>"},{"location":"api/#ada_verona.ONNXNetwork.from_dict","title":"<code>from_dict(data)</code>  <code>classmethod</code>","text":"<p>Create a Network from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>The dictionary containing the Network attributes.</p> required <p>Returns:</p> Name Type Description <code>Network</code> <code>ONNXNetwork</code> <p>The created Network.</p> Source code in <code>ada_verona/database/machine_learning_model/onnx_network.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: dict)-&gt; \"ONNXNetwork\":\n    \"\"\"\n    Create a Network from a dictionary.\n\n    Args:\n        data (dict): The dictionary containing the Network attributes.\n\n    Returns:\n        Network: The created Network.\n    \"\"\"\n    return cls(path = data['network_path'])\n</code></pre>"},{"location":"api/#ada_verona.ONNXNetwork.from_file","title":"<code>from_file(file)</code>  <code>classmethod</code>","text":"<p>Create a ONNXNetwork from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>Path</code> <p>Path at which the network is stored. </p> required <p>Returns:</p> Name Type Description <code>ONNXNetwork</code> <code>ONNXNetwork</code> <p>The created ONNXNetwork.</p> Source code in <code>ada_verona/database/machine_learning_model/onnx_network.py</code> <pre><code>@classmethod\ndef from_file(cls, file:Path)-&gt; \"ONNXNetwork\":\n    \"\"\"\n    Create a ONNXNetwork from a dictionary.\n\n    Args:\n        file (Path): Path at which the network is stored. \n\n    Returns:\n        ONNXNetwork: The created ONNXNetwork.\n    \"\"\"\n\n    if not file.is_file():\n        raise FileNotFoundError(f\"File not found: {file}\")\n\n    return cls(path = file)\n</code></pre>"},{"location":"api/#ada_verona.ONNXNetwork.get_input_shape","title":"<code>get_input_shape()</code>","text":"<p>Get the input shape of the ONNX model.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The input shape of the ONNX model.</p> Source code in <code>ada_verona/database/machine_learning_model/onnx_network.py</code> <pre><code>def get_input_shape(self) -&gt; np.ndarray:\n    \"\"\"\n    Get the input shape of the ONNX model.\n\n    Returns:\n        np.ndarray: The input shape of the ONNX model.\n    \"\"\"\n    model = self.load_onnx_model()\n    input_shape = tuple([d.dim_value for d in model.graph.input[0].type.tensor_type.shape.dim])\n    input_shape = [x if x != 0 else -1 for x in input_shape]\n\n    return input_shape\n</code></pre>"},{"location":"api/#ada_verona.ONNXNetwork.load_onnx_model","title":"<code>load_onnx_model()</code>","text":"<p>Load the ONNX model from the network path.</p> <p>Returns:</p> Type Description <code>ModelProto</code> <p>onnx.ModelProto: The loaded ONNX model.</p> Source code in <code>ada_verona/database/machine_learning_model/onnx_network.py</code> <pre><code>def load_onnx_model(self) -&gt; onnx.ModelProto:\n    \"\"\"\n    Load the ONNX model from the network path.\n\n    Returns:\n        onnx.ModelProto: The loaded ONNX model.\n    \"\"\"\n    model = self.onnx_model\n    if model is None:\n        model = onnx.load(str(self.path))\n        self.onnx_model = model\n\n    return model\n</code></pre>"},{"location":"api/#ada_verona.ONNXNetwork.load_pytorch_model","title":"<code>load_pytorch_model()</code>","text":"<p>Load the PyTorch model from the ONNX model.</p> <p>Returns:</p> Type Description <code>Module</code> <p>torch.nn.Module: The loaded PyTorch model.</p> Source code in <code>ada_verona/database/machine_learning_model/onnx_network.py</code> <pre><code>def load_pytorch_model(self) -&gt; torch.nn.Module:\n    \"\"\"\n    Load the PyTorch model from the ONNX model.\n\n    Returns:\n        torch.nn.Module: The loaded PyTorch model.\n    \"\"\"\n    device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n    torch_model_wrapper = self.torch_model_wrapper\n    if torch_model_wrapper is None:\n        torch_model = convert(self.path).to(device)\n        torch_model_wrapper = TorchModelWrapper(torch_model, self.get_input_shape())\n        self.torch_model_wrapper = torch_model_wrapper\n\n    return torch_model_wrapper\n</code></pre>"},{"location":"api/#ada_verona.ONNXNetwork.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert the Network to a dictionary.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The dictionary representation of the Network.</p> Source code in <code>ada_verona/database/machine_learning_model/onnx_network.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"\n    Convert the Network to a dictionary.\n\n    Returns:\n        dict: The dictionary representation of the Network.\n    \"\"\"\n\n    return dict(network_path =  str(self.path), \n            type=self.__class__.__name__,\n            module=self.__class__.__module__,\n                )\n</code></pre>"},{"location":"api/#ada_verona.PyTorchNetwork","title":"<code>PyTorchNetwork</code>","text":"<p>               Bases: <code>Network</code></p> <p>A class representing a PyTorch network with architecture and weights files.</p> <p>Attributes:</p> Name Type Description <code>model</code> <code>Module</code> <p>The loaded PyTorch model. Defaults to None.</p> <code>torch_model_wrapper</code> <code>TorchModelWrapper</code> <p>The PyTorch model wrapper. Defaults to None.</p> <code>name</code> <code>str</code> <p>A chosen name for the model.</p> <code>input_shape</code> <code>tuple[int]</code> <p>Input shape of the model.</p> Source code in <code>ada_verona/database/machine_learning_model/pytorch_network.py</code> <pre><code>class PyTorchNetwork(Network):\n    \"\"\"\n    A class representing a PyTorch network with architecture and weights files.\n\n    Attributes:\n        model (torch.nn.Module, optional): The loaded PyTorch model. Defaults to None.\n        torch_model_wrapper (TorchModelWrapper, optional): The PyTorch model wrapper. Defaults to None.\n        name: A chosen name for the model.\n        input_shape (tuple[int]): Input shape of the model.\n    \"\"\"\n\n    def __init__(self, model: torch.nn.Module, input_shape: tuple[int], name: str, path: Path | None = None) -&gt; None:\n        \"\"\"\n        Initialize the PyTorchNetwork with architecture and weights paths.\n\n        Args:\n            model (torch.nn.Module, optional): The loaded PyTorch model. Defaults to None.\n            input_shape (tuple[int]): Input shape of the model.\n            name: A chosen name for the model.\n        \"\"\"\n\n        self.model = model\n        self.input_shape = input_shape\n        self._name = name\n        self._path = path\n        self.torch_model_wrapper = None\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"\n        Get the name of the network.\n\n        Returns:\n            str: The name of the network.\n        \"\"\"\n        return self._name\n\n    @property\n    def path(self) -&gt; Path:\n        \"\"\"\n        Get the path of the network.\n\n        Returns:\n            Path: The path of the network.\n        \"\"\"\n        return self._path\n\n    def get_input_shape(self) -&gt; np.ndarray:\n        \"\"\"\n        Get the input shape of the PyTorch model.\n\n        Returns:\n            np.ndarray: the input_shape\n        \"\"\"\n\n        return self.input_shape\n\n    def load_pytorch_model(self) -&gt; torch.nn.Module:\n        \"\"\"\n        Load the PyTorch model and wrap it in a TorchModelWrapper.\n\n        Returns:\n            torch.nn.Module: The wrapped PyTorch model.\n        \"\"\"\n        if self.torch_model_wrapper is None:\n            device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n            model = self.model.to(device)\n            model.eval()\n\n            self.torch_model_wrapper = TorchModelWrapper(model, self.get_input_shape())\n\n        return self.torch_model_wrapper\n\n    def to_dict(self):\n        raise NotImplementedError(\"PytorchNetwork does not support to_dict() function currently.\")\n\n    def from_dict(cls, data: dict):\n        raise NotImplementedError(\"PytorchNetwork does not support from_dict() function currently.\")\n</code></pre>"},{"location":"api/#ada_verona.PyTorchNetwork.name","title":"<code>name</code>  <code>property</code>","text":"<p>Get the name of the network.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The name of the network.</p>"},{"location":"api/#ada_verona.PyTorchNetwork.path","title":"<code>path</code>  <code>property</code>","text":"<p>Get the path of the network.</p> <p>Returns:</p> Name Type Description <code>Path</code> <code>Path</code> <p>The path of the network.</p>"},{"location":"api/#ada_verona.PyTorchNetwork.__init__","title":"<code>__init__(model, input_shape, name, path=None)</code>","text":"<p>Initialize the PyTorchNetwork with architecture and weights paths.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Module</code> <p>The loaded PyTorch model. Defaults to None.</p> required <code>input_shape</code> <code>tuple[int]</code> <p>Input shape of the model.</p> required <code>name</code> <code>str</code> <p>A chosen name for the model.</p> required Source code in <code>ada_verona/database/machine_learning_model/pytorch_network.py</code> <pre><code>def __init__(self, model: torch.nn.Module, input_shape: tuple[int], name: str, path: Path | None = None) -&gt; None:\n    \"\"\"\n    Initialize the PyTorchNetwork with architecture and weights paths.\n\n    Args:\n        model (torch.nn.Module, optional): The loaded PyTorch model. Defaults to None.\n        input_shape (tuple[int]): Input shape of the model.\n        name: A chosen name for the model.\n    \"\"\"\n\n    self.model = model\n    self.input_shape = input_shape\n    self._name = name\n    self._path = path\n    self.torch_model_wrapper = None\n</code></pre>"},{"location":"api/#ada_verona.PyTorchNetwork.get_input_shape","title":"<code>get_input_shape()</code>","text":"<p>Get the input shape of the PyTorch model.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: the input_shape</p> Source code in <code>ada_verona/database/machine_learning_model/pytorch_network.py</code> <pre><code>def get_input_shape(self) -&gt; np.ndarray:\n    \"\"\"\n    Get the input shape of the PyTorch model.\n\n    Returns:\n        np.ndarray: the input_shape\n    \"\"\"\n\n    return self.input_shape\n</code></pre>"},{"location":"api/#ada_verona.PyTorchNetwork.load_pytorch_model","title":"<code>load_pytorch_model()</code>","text":"<p>Load the PyTorch model and wrap it in a TorchModelWrapper.</p> <p>Returns:</p> Type Description <code>Module</code> <p>torch.nn.Module: The wrapped PyTorch model.</p> Source code in <code>ada_verona/database/machine_learning_model/pytorch_network.py</code> <pre><code>def load_pytorch_model(self) -&gt; torch.nn.Module:\n    \"\"\"\n    Load the PyTorch model and wrap it in a TorchModelWrapper.\n\n    Returns:\n        torch.nn.Module: The wrapped PyTorch model.\n    \"\"\"\n    if self.torch_model_wrapper is None:\n        device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n        model = self.model.to(device)\n        model.eval()\n\n        self.torch_model_wrapper = TorchModelWrapper(model, self.get_input_shape())\n\n    return self.torch_model_wrapper\n</code></pre>"},{"location":"api/#ada_verona.TorchModelWrapper","title":"<code>TorchModelWrapper</code>","text":"<p>               Bases: <code>Module</code></p> <p>A wrapper class for a PyTorch model to reshape the input before passing it to the model.</p> Source code in <code>ada_verona/database/machine_learning_model/torch_model_wrapper.py</code> <pre><code>class TorchModelWrapper(torch.nn.Module):\n    \"\"\"\n    A wrapper class for a PyTorch model to reshape the input before passing it to the model.\n    \"\"\"\n\n    def __init__(self, torch_model: torch.nn.Module, input_shape: tuple[int]):\n        \"\"\"\n        Initialize the TorchModelWrapper with the given PyTorch model and input shape.\n\n        Args:\n            torch_model (torch.nn.Module): The PyTorch model to wrap.\n            input_shape: The input shape to reshape the input tensor. Can be tuple[int] or np.ndarray.\n        \"\"\"\n        super().__init__()\n        self.torch_model = torch_model\n        self.input_shape = input_shape\n\n    def forward(self, x):\n        \"\"\"\n        Forward pass of the TorchModelWrapper.\n\n        Args:\n            x (torch.Tensor): The input tensor.\n\n        Returns:\n            torch.Tensor: The output tensor from the wrapped PyTorch model.\n        \"\"\"\n\n        if isinstance(x, np.ndarray):\n        # ensure correct dtype/device if needed\n            x = torch.from_numpy(x).to(\n                dtype=torch.float32,\n                device=next(self.torch_model.parameters()).device\n            )\n            x = x.reshape(*self.input_shape)  # tuple unpacking\n\n        else:\n        # Assume it's already a torch.Tensor\n            x = x.reshape(*self.input_shape)\n\n        x = self.torch_model(x)\n        return x\n</code></pre>"},{"location":"api/#ada_verona.TorchModelWrapper.__init__","title":"<code>__init__(torch_model, input_shape)</code>","text":"<p>Initialize the TorchModelWrapper with the given PyTorch model and input shape.</p> <p>Parameters:</p> Name Type Description Default <code>torch_model</code> <code>Module</code> <p>The PyTorch model to wrap.</p> required <code>input_shape</code> <code>tuple[int]</code> <p>The input shape to reshape the input tensor. Can be tuple[int] or np.ndarray.</p> required Source code in <code>ada_verona/database/machine_learning_model/torch_model_wrapper.py</code> <pre><code>def __init__(self, torch_model: torch.nn.Module, input_shape: tuple[int]):\n    \"\"\"\n    Initialize the TorchModelWrapper with the given PyTorch model and input shape.\n\n    Args:\n        torch_model (torch.nn.Module): The PyTorch model to wrap.\n        input_shape: The input shape to reshape the input tensor. Can be tuple[int] or np.ndarray.\n    \"\"\"\n    super().__init__()\n    self.torch_model = torch_model\n    self.input_shape = input_shape\n</code></pre>"},{"location":"api/#ada_verona.TorchModelWrapper.forward","title":"<code>forward(x)</code>","text":"<p>Forward pass of the TorchModelWrapper.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Tensor</code> <p>The input tensor.</p> required <p>Returns:</p> Type Description <p>torch.Tensor: The output tensor from the wrapped PyTorch model.</p> Source code in <code>ada_verona/database/machine_learning_model/torch_model_wrapper.py</code> <pre><code>def forward(self, x):\n    \"\"\"\n    Forward pass of the TorchModelWrapper.\n\n    Args:\n        x (torch.Tensor): The input tensor.\n\n    Returns:\n        torch.Tensor: The output tensor from the wrapped PyTorch model.\n    \"\"\"\n\n    if isinstance(x, np.ndarray):\n    # ensure correct dtype/device if needed\n        x = torch.from_numpy(x).to(\n            dtype=torch.float32,\n            device=next(self.torch_model.parameters()).device\n        )\n        x = x.reshape(*self.input_shape)  # tuple unpacking\n\n    else:\n    # Assume it's already a torch.Tensor\n        x = x.reshape(*self.input_shape)\n\n    x = self.torch_model(x)\n    return x\n</code></pre>"},{"location":"api/#ada_verona.VNNLibProperty","title":"<code>VNNLibProperty</code>  <code>dataclass</code>","text":"<p>Dataclass for a VNNLib property.</p> Source code in <code>ada_verona/database/vnnlib_property.py</code> <pre><code>@dataclass\nclass VNNLibProperty:\n    \"\"\"Dataclass for a VNNLib property.\"\"\"\n\n    name: str\n    content: str\n    path: Path = None\n</code></pre>"},{"location":"api/#ada_verona.VerificationContext","title":"<code>VerificationContext</code>","text":"<p>A class to represent the context for verification. This class saves all the relevant information for a verification run.</p> Source code in <code>ada_verona/database/verification_context.py</code> <pre><code>class VerificationContext:\n    \"\"\"\n    A class to represent the context for verification.\n    This class saves all the relevant information for a verification run.\n    \"\"\"\n\n    def __init__(\n        self,\n        network: Network,\n        data_point: DataPoint,\n        tmp_path: Path,\n        property_generator: PropertyGenerator,\n        save_epsilon_results: bool = True,\n    ) -&gt; None:\n        \"\"\"\n        Initialize the VerificationContext with the given parameters.\n\n        Args:\n            network (Network): The network to be verified.\n            data_point (DataPoint): The data point to be verified.\n            tmp_path (Path): The temporary path for saving intermediate results.\n            property_generator (PropertyGenerator): The property generator for creating verification properties.\n            save_epsilon_results (bool, optional): Whether to save epsilon results. Defaults to True.\n        \"\"\"\n        self.network = network\n        self.data_point = data_point\n        self.tmp_path = tmp_path\n        self.property_generator = property_generator\n        self.save_epsilon_results = save_epsilon_results\n\n        if save_epsilon_results and not self.tmp_path.exists():\n            self.tmp_path.mkdir(parents=True)\n\n    def get_dict_for_epsilon_result(self) -&gt; dict:\n        \"\"\"\n        Get a dictionary representation of the epsilon result.\n\n        Returns:\n            dict: The dictionary representation of the epsilon result.\n        \"\"\"\n        return dict(\n            network=self.network.name,\n            image_id=self.data_point.id,\n            original_label=self.data_point.label,\n            tmp_path=self.tmp_path.resolve(),\n            **self.property_generator.get_dict_for_epsilon_result(),\n        )\n\n    def save_vnnlib_property(self, vnnlib_property: VNNLibProperty) -&gt; None:\n        \"\"\"\n        Save the VNNLib property to a file in the temporary path.\n\n        Args:\n            vnnlib_property (VNNLibProperty): The VNNLib property object to be saved.\n        \"\"\"\n        if not self.tmp_path.exists():\n            self.tmp_path.mkdir(parents=True)\n        save_path = self.tmp_path / f\"{vnnlib_property.name}.vnnlib\"\n\n        with open(save_path, \"w\") as f:\n            f.write(vnnlib_property.content)\n        vnnlib_property.path = save_path\n\n    def delete_tmp_path(self) -&gt; None:\n        \"\"\"\n        Delete the temporary path and its contents.\n        \"\"\"\n\n        self.tmp_path.unlink()\n\n    def save_status_list(self, epsilon_status_list: list[EpsilonStatus]) -&gt; None:\n        \"\"\"\n        Save the list of epsilon statuses to a CSV file.\n\n        Args:\n            epsilon_status_list (list[EpsilonStatus]): The list of epsilon statuses to save.\n        \"\"\"\n        save_path = self.tmp_path / \"epsilon_results.csv\"\n        data = [x.to_dict() for x in epsilon_status_list]\n        df = pd.DataFrame(data=data)\n        df.to_csv(save_path)\n\n    def save_result(self, result: EpsilonStatus) -&gt; None:\n        \"\"\"\n        Save a single epsilon status result to the CSV file.\n\n        Args:\n            result (EpsilonStatus): The epsilon status result to save.\n        \"\"\"\n        if self.save_epsilon_results:\n            result_df_path = self.tmp_path / \"epsilons_df.csv\"\n            if result_df_path.exists():\n                df = pd.read_csv(result_df_path, index_col=0)\n                df.loc[len(df.index)] = result.to_dict()\n            else:\n                df = pd.DataFrame([result.to_dict()])\n            df.to_csv(result_df_path)\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"\n        Convert the VerificationContext to a dictionary.\n\n        Returns:\n            dict: The dictionary representation of the VerificationContext.\n        \"\"\"\n        return {\n            \"network\": self.network.to_dict(),\n            \"data_point\": self.data_point.to_dict(),\n            \"tmp_path\": str(self.tmp_path),\n            \"property_generator\": self.property_generator.to_dict(),\n            \"save_epsilon_results\": self.save_epsilon_results,\n        }\n\n    @classmethod\n    def from_dict(cls, data: dict) -&gt; \"VerificationContext\":\n        \"\"\"\n        Create a VerificationContext from a dictionary.\n\n        Args:\n            data (dict): The dictionary containing the VerificationContext attributes.\n\n        Returns:\n            VerificationContext: The created VerificationContext.\n        \"\"\"\n        # Recreate the network from its dictionary representation\n\n        network = ONNXNetwork.from_dict(data[\"network\"])\n        data_point = DataPoint.from_dict(data[\"data_point\"])\n        tmp_path = Path(data[\"tmp_path\"])\n        property_generator = PropertyGenerator.from_dict(data[\"property_generator\"])\n        save_epsilon_results = data[\"save_epsilon_results\"]\n        return cls(\n            network=network,\n            data_point=data_point,\n            tmp_path=tmp_path,\n            property_generator=property_generator,\n            save_epsilon_results=save_epsilon_results,\n        )\n</code></pre>"},{"location":"api/#ada_verona.VerificationContext.__init__","title":"<code>__init__(network, data_point, tmp_path, property_generator, save_epsilon_results=True)</code>","text":"<p>Initialize the VerificationContext with the given parameters.</p> <p>Parameters:</p> Name Type Description Default <code>network</code> <code>Network</code> <p>The network to be verified.</p> required <code>data_point</code> <code>DataPoint</code> <p>The data point to be verified.</p> required <code>tmp_path</code> <code>Path</code> <p>The temporary path for saving intermediate results.</p> required <code>property_generator</code> <code>PropertyGenerator</code> <p>The property generator for creating verification properties.</p> required <code>save_epsilon_results</code> <code>bool</code> <p>Whether to save epsilon results. Defaults to True.</p> <code>True</code> Source code in <code>ada_verona/database/verification_context.py</code> <pre><code>def __init__(\n    self,\n    network: Network,\n    data_point: DataPoint,\n    tmp_path: Path,\n    property_generator: PropertyGenerator,\n    save_epsilon_results: bool = True,\n) -&gt; None:\n    \"\"\"\n    Initialize the VerificationContext with the given parameters.\n\n    Args:\n        network (Network): The network to be verified.\n        data_point (DataPoint): The data point to be verified.\n        tmp_path (Path): The temporary path for saving intermediate results.\n        property_generator (PropertyGenerator): The property generator for creating verification properties.\n        save_epsilon_results (bool, optional): Whether to save epsilon results. Defaults to True.\n    \"\"\"\n    self.network = network\n    self.data_point = data_point\n    self.tmp_path = tmp_path\n    self.property_generator = property_generator\n    self.save_epsilon_results = save_epsilon_results\n\n    if save_epsilon_results and not self.tmp_path.exists():\n        self.tmp_path.mkdir(parents=True)\n</code></pre>"},{"location":"api/#ada_verona.VerificationContext.delete_tmp_path","title":"<code>delete_tmp_path()</code>","text":"<p>Delete the temporary path and its contents.</p> Source code in <code>ada_verona/database/verification_context.py</code> <pre><code>def delete_tmp_path(self) -&gt; None:\n    \"\"\"\n    Delete the temporary path and its contents.\n    \"\"\"\n\n    self.tmp_path.unlink()\n</code></pre>"},{"location":"api/#ada_verona.VerificationContext.from_dict","title":"<code>from_dict(data)</code>  <code>classmethod</code>","text":"<p>Create a VerificationContext from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>The dictionary containing the VerificationContext attributes.</p> required <p>Returns:</p> Name Type Description <code>VerificationContext</code> <code>VerificationContext</code> <p>The created VerificationContext.</p> Source code in <code>ada_verona/database/verification_context.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: dict) -&gt; \"VerificationContext\":\n    \"\"\"\n    Create a VerificationContext from a dictionary.\n\n    Args:\n        data (dict): The dictionary containing the VerificationContext attributes.\n\n    Returns:\n        VerificationContext: The created VerificationContext.\n    \"\"\"\n    # Recreate the network from its dictionary representation\n\n    network = ONNXNetwork.from_dict(data[\"network\"])\n    data_point = DataPoint.from_dict(data[\"data_point\"])\n    tmp_path = Path(data[\"tmp_path\"])\n    property_generator = PropertyGenerator.from_dict(data[\"property_generator\"])\n    save_epsilon_results = data[\"save_epsilon_results\"]\n    return cls(\n        network=network,\n        data_point=data_point,\n        tmp_path=tmp_path,\n        property_generator=property_generator,\n        save_epsilon_results=save_epsilon_results,\n    )\n</code></pre>"},{"location":"api/#ada_verona.VerificationContext.get_dict_for_epsilon_result","title":"<code>get_dict_for_epsilon_result()</code>","text":"<p>Get a dictionary representation of the epsilon result.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The dictionary representation of the epsilon result.</p> Source code in <code>ada_verona/database/verification_context.py</code> <pre><code>def get_dict_for_epsilon_result(self) -&gt; dict:\n    \"\"\"\n    Get a dictionary representation of the epsilon result.\n\n    Returns:\n        dict: The dictionary representation of the epsilon result.\n    \"\"\"\n    return dict(\n        network=self.network.name,\n        image_id=self.data_point.id,\n        original_label=self.data_point.label,\n        tmp_path=self.tmp_path.resolve(),\n        **self.property_generator.get_dict_for_epsilon_result(),\n    )\n</code></pre>"},{"location":"api/#ada_verona.VerificationContext.save_result","title":"<code>save_result(result)</code>","text":"<p>Save a single epsilon status result to the CSV file.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>EpsilonStatus</code> <p>The epsilon status result to save.</p> required Source code in <code>ada_verona/database/verification_context.py</code> <pre><code>def save_result(self, result: EpsilonStatus) -&gt; None:\n    \"\"\"\n    Save a single epsilon status result to the CSV file.\n\n    Args:\n        result (EpsilonStatus): The epsilon status result to save.\n    \"\"\"\n    if self.save_epsilon_results:\n        result_df_path = self.tmp_path / \"epsilons_df.csv\"\n        if result_df_path.exists():\n            df = pd.read_csv(result_df_path, index_col=0)\n            df.loc[len(df.index)] = result.to_dict()\n        else:\n            df = pd.DataFrame([result.to_dict()])\n        df.to_csv(result_df_path)\n</code></pre>"},{"location":"api/#ada_verona.VerificationContext.save_status_list","title":"<code>save_status_list(epsilon_status_list)</code>","text":"<p>Save the list of epsilon statuses to a CSV file.</p> <p>Parameters:</p> Name Type Description Default <code>epsilon_status_list</code> <code>list[EpsilonStatus]</code> <p>The list of epsilon statuses to save.</p> required Source code in <code>ada_verona/database/verification_context.py</code> <pre><code>def save_status_list(self, epsilon_status_list: list[EpsilonStatus]) -&gt; None:\n    \"\"\"\n    Save the list of epsilon statuses to a CSV file.\n\n    Args:\n        epsilon_status_list (list[EpsilonStatus]): The list of epsilon statuses to save.\n    \"\"\"\n    save_path = self.tmp_path / \"epsilon_results.csv\"\n    data = [x.to_dict() for x in epsilon_status_list]\n    df = pd.DataFrame(data=data)\n    df.to_csv(save_path)\n</code></pre>"},{"location":"api/#ada_verona.VerificationContext.save_vnnlib_property","title":"<code>save_vnnlib_property(vnnlib_property)</code>","text":"<p>Save the VNNLib property to a file in the temporary path.</p> <p>Parameters:</p> Name Type Description Default <code>vnnlib_property</code> <code>VNNLibProperty</code> <p>The VNNLib property object to be saved.</p> required Source code in <code>ada_verona/database/verification_context.py</code> <pre><code>def save_vnnlib_property(self, vnnlib_property: VNNLibProperty) -&gt; None:\n    \"\"\"\n    Save the VNNLib property to a file in the temporary path.\n\n    Args:\n        vnnlib_property (VNNLibProperty): The VNNLib property object to be saved.\n    \"\"\"\n    if not self.tmp_path.exists():\n        self.tmp_path.mkdir(parents=True)\n    save_path = self.tmp_path / f\"{vnnlib_property.name}.vnnlib\"\n\n    with open(save_path, \"w\") as f:\n        f.write(vnnlib_property.content)\n    vnnlib_property.path = save_path\n</code></pre>"},{"location":"api/#ada_verona.VerificationContext.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert the VerificationContext to a dictionary.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The dictionary representation of the VerificationContext.</p> Source code in <code>ada_verona/database/verification_context.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"\n    Convert the VerificationContext to a dictionary.\n\n    Returns:\n        dict: The dictionary representation of the VerificationContext.\n    \"\"\"\n    return {\n        \"network\": self.network.to_dict(),\n        \"data_point\": self.data_point.to_dict(),\n        \"tmp_path\": str(self.tmp_path),\n        \"property_generator\": self.property_generator.to_dict(),\n        \"save_epsilon_results\": self.save_epsilon_results,\n    }\n</code></pre>"},{"location":"api/#ada_verona.VerificationModule","title":"<code>VerificationModule</code>","text":"<p>               Bases: <code>ABC</code></p> Source code in <code>ada_verona/verification_module/verification_module.py</code> <pre><code>class VerificationModule(ABC):\n    @abstractmethod\n    def verify(self, verification_context: VerificationContext, epsilon: float) -&gt; str | CompleteVerificationData:\n        \"\"\"Main method to verify an image (or other data instance) for a given network and epsilon value.\"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"api/#ada_verona.VerificationModule.verify","title":"<code>verify(verification_context, epsilon)</code>  <code>abstractmethod</code>","text":"<p>Main method to verify an image (or other data instance) for a given network and epsilon value.</p> Source code in <code>ada_verona/verification_module/verification_module.py</code> <pre><code>@abstractmethod\ndef verify(self, verification_context: VerificationContext, epsilon: float) -&gt; str | CompleteVerificationData:\n    \"\"\"Main method to verify an image (or other data instance) for a given network and epsilon value.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/#ada_verona.VerificationResult","title":"<code>VerificationResult</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Class for saving the possible verification results. At this point we are using the same Result strings for complete verification and attacks.</p> Source code in <code>ada_verona/database/verification_result.py</code> <pre><code>class VerificationResult(str, Enum):\n    \"\"\"Class for saving the possible verification results.\n    At this point we are using the same Result strings for complete verification and attacks.\n    \"\"\"\n\n    UNSAT = \"UNSAT\"\n    SAT = \"SAT\"\n    TIMEOUT = \"TIMEOUT\"\n    ERROR = \"ERR\"\n</code></pre>"},{"location":"developer-notes/","title":"Developer Notes","text":"<p>This page contains essential information for developers contributing to or maintaining the ada-verona package.</p>"},{"location":"developer-notes/#local-installation-for-eg-development-purposes","title":"Local installation for e.g. development purposes","text":"<p>If you want to install ada-verona locally using git:</p> <pre><code>git clone https://github.com/ADA-research/VERONA.git\ncd VERONA\nuv pip install -e .\nuv pip install -e .[dev]  # to include development dependencies\n</code></pre>"},{"location":"developer-notes/#pre-commit-hooks","title":"Pre-Commit Hooks","text":"<p>We use pre-commit to automatically enforce code quality standards and consistency before commits. </p> <p>Pre-commit is included in the dev dependencies. After installing the dev environment, set up the git hooks:</p> <pre><code>pre-commit install\n</code></pre> <p>This command hooks into your Git workflow and runs configured checks on staged files before each commit.</p>"},{"location":"developer-notes/#skipping-specific-hooks","title":"Skipping Specific Hooks","text":"<p>To skip a specific hook for a single commit, use the <code>SKIP</code> environment variable, e.g.:</p> <pre><code>SKIP=check-pyproject-requirements-sync git commit -m \"Your message\"\n</code></pre>"},{"location":"developer-notes/#opening-a-pr","title":"Opening a PR","text":"<p>Before opening a PR, please do the following steps:</p> <ul> <li>Check you implementation and all the files you changed for the PR</li> <li>Execute the tests <code>python -m pytest --cov tests/ --verbose</code> and check everything is passing</li> <li>Create a new branch and upload you changes to GitHub</li> <li>Open your PR, check that all workflows are passing and document your changes by describing:<ul> <li>What is the purpose of the PR and what issue is addressed.</li> <li>What exactly was changed in this PR. </li> <li>How did you test the changes.</li> </ul> </li> <li>After you documented the PR and checked that the workflows are passing assign a reviewer to the PR</li> </ul>"},{"location":"developer-notes/#testing-the-documentation","title":"Testing the documentation","text":"<ul> <li>Check the documentation locally using <code>mkdocs serve</code></li> </ul>"},{"location":"developer-notes/#package-release-steps","title":"Package Release Steps","text":""},{"location":"developer-notes/#prerequisites","title":"Prerequisites","text":"<p>Ensure you have the necessary permissions and setup for PyPI releases:</p> <ul> <li>You must be a member of the PyPI ada-verona project with release authority</li> <li>Configure trusted publishing with your credentials on PyPI</li> </ul>"},{"location":"developer-notes/#1-bump-version-locally","title":"1. Bump Version Locally","text":"<p>Use <code>uv</code> to automatically update the version in <code>pyproject.toml</code> and <code>uv.lock</code>:</p> <pre><code># For patch version (1.0.0 \u2192 1.0.1)\nuv version --bump patch\n\n# For minor version (1.0.0 \u2192 1.1.0)\nuv version --bump minor\n\n# For major version (1.0.0 \u2192 2.0.0)\nuv version --bump major\n</code></pre> <p>The package version is automatically resolved at runtime via <code>importlib.metadata.version(\"ada-verona\")</code>.</p>"},{"location":"developer-notes/#2-commit-version-changes","title":"2. Commit Version Changes","text":"<pre><code>git add pyproject.toml uv.lock\ngit commit -m \"Bump version to 1.0.0-alpha.10\"\n</code></pre>"},{"location":"developer-notes/#3-create-and-push-git-tag","title":"3. Create and Push Git Tag","text":"<p>Important: Use the <code>v</code> prefix for the git tag, as this triggers the release workflow.</p> <pre><code># Create tag matching the version\ngit tag v1.0.0\n\n# Push commit and tag together\ngit push origin main\ngit push origin v1.0.0\n</code></pre>"},{"location":"developer-notes/#4-review-and-approve-workflow","title":"4. Review and Approve Workflow","text":"<p>The release workflow requires approval from at least one council member (see governance.md) before deployment. Monitor the GitHub Actions page for the workflow run and approve it as needed.</p>"},{"location":"how-to-guides/","title":"How to guides","text":"<p>To help you get up and running with ada-verona, we provide a tutorial notebook and a collection of example scripts:</p> <ul> <li> <p>Main Guide:</p> <ul> <li>The primary resource for learning how to use VERONA is the Jupyter notebook found in the <code>notebooks</code> folder. This tutorial notebook offers an overview of the package components, step-by-step instructions, and practical demonstrations of typical workflows. We highly recommend starting here to understand the core concepts and capabilities of the package.</li> </ul> </li> <li> <p>Quick-Start Example Scripts:</p> <ul> <li>The <code>scripts</code> folder contains a variety of example scripts designed to help you get started quickly with ada-verona. These scripts cover common use cases and can be run directly (from within the <code>scripts</code> folder) to see how to perform tasks such as:<ul> <li>Running VERONA with a custom dataset and ab-crown (<code>create_robustness_distribution_from_test_dataset.py</code>).</li> <li>Loading a PyTorch dataset and running VERONA with one-to-any or one-to-one verification (<code>create_robustness_dist_on_pytorch_dataset.py</code>).</li> <li>Distributing jobs across multiple nodes using SLURM for large-scale experiments (<code>multiple_jobs</code> folder), including distributing tasks over CPU and GPU for different verifiers in the same experiment.</li> <li>Using auto-verify integration (<code>create_robustness_dist_with_auto_verify.py</code>).</li> </ul> </li> </ul> </li> </ul> <p>The notebook is your main entry point for learning and understanding the package, while the scripts serve as practical templates and quick-start resources for your own experiments.</p>"},{"location":"how-to-guides/#setting-up-the-experiment-directory","title":"Setting up the Experiment Directory","text":"<p>The experiment directory structure by default is expected as follows:</p> <p>Note: You must provide ONNX or torch network files in the networks directory. ada-verona will create directories automatically, but you need to supply your own network models. <pre><code>experiment/\n|-- data/\n|   |-- labels.csv\n|   |-- images/\n|       |-- mnist_0.npy\n|       |-- mnist_1.npy\n|       |-- ...\n|-- networks/\n|   |-- mnist-net_256x2.onnx\n|   |-- mnist-net_256x4.onnx\n|   |-- ...\n</code></pre></p>"},{"location":"how-to-guides/#verification","title":"Verification","text":""},{"location":"how-to-guides/#auto-verify","title":"Auto-Verify","text":"<p>VERONA features a plugin architecture through the <code>AutoVerifyModule</code> which allows integration with auto-verify when it's installed in the same environment.  AutoVerify handles installation of various verifiers (see next section) as well as configuration and execution of the verifiers. </p> <p>This design provides several benefits:</p> <ol> <li>Independence: VERONA works perfectly without auto-verify, using attack-based verification methods for empirical upper bounds.</li> <li>Automatic Detection: When auto-verify is installed in the same environment, its verifiers become automatically available</li> <li>Interface: The same API works regardless of which verification backend is used</li> </ol> <p>Auto-Verify can be installed in the following way: </p> <p>Note: On macOS (and sometimes on Linux), you may need to install <code>swig</code> first with <code>conda install -c conda-forge swig</code>.</p> <p><pre><code>uv pip install auto-verify&gt;=0.1.4\n</code></pre> It is important to note that in order to use AutoVerify in VERONA, the pip version for AutoVerify must be &gt;=0.1.4.</p>"},{"location":"how-to-guides/#available-verifiers","title":"Available Verifiers","text":"<p>Currently, auto-verify supports nnenum, AB-Crown, VeriNet, and Oval-Bab. We thank the authors and maintainers of these projects for their contributions to the robustness research community.</p> <p>We plan to add more verifiers to auto-verify in the future. For additional information about auto-verify, please refer to the official GitHub repository and documentation. Verifiers can be installed using the <code>auto-verify</code> command, e.g. to install nnenum and abcrown:</p> <p><pre><code>auto-verify install nnenum abcrown\n</code></pre> To see the current configuration of auto-verify, you can use the <code>auto-verify config show</code> command.</p> <pre><code>auto-verify config show\n</code></pre>"},{"location":"how-to-guides/#possible-extension-how-to-add-your-own-verifier","title":"Possible Extension: How to Add Your Own Verifier","text":"<p>Custom verifiers can be added to VERONA by using the <code>VerificationModule</code> interface.</p> <p>Implement new verifiers using the <code>VerificationModule</code> class:</p> <ul> <li>Create a new class that inherits from <code>VerificationModule</code>.</li> <li>Implement the <code>verify(self, verification_context: VerificationContext, epsilon: float)</code> method. This method should return either a string (e.g., \"SAT\", \"UNSAT\", \"ERR\") or a <code>CompleteVerificationData</code> object.</li> </ul> <p>Example: <pre><code>from ada_verona.verification_module.verification_module import VerificationModule\n\nclass MyCustomVerifier(VerificationModule):\n    def verify(self, verification_context, epsilon):\n        # Your custom verification logic here\n        # Return \"SAT\", \"UNSAT\", or a CompleteVerificationData object\n        return \"UNSAT\"\n</code></pre></p>"},{"location":"how-to-guides/#adversarial-attacks","title":"Adversarial Attacks","text":"<p>VERONA implements the following adversarial attack methods:</p> <ul> <li>Fast Gradient Sign Method (FGSM) - Goodfellow et al., 2015</li> <li>Projected Gradient Descent (PGD) - Madry et al., 2018</li> <li>AutoAttack - Croce and Hein, 2020</li> </ul>"},{"location":"how-to-guides/#optional-autoattack-installation","title":"Optional: AutoAttack Installation","text":"<p>To use the <code>AutoAttackWrapper</code> class, you need to install AutoAttack separately from its GitHub repository:</p> <pre><code>uv pip install git+https://github.com/fra31/auto-attack\n</code></pre> <p>This package provides ensemble-based adversarial attacks for robustness evaluation. When installed, <code>AutoAttackWrapper</code> becomes automatically available in <code>ada_verona</code>.</p>"},{"location":"how-to-guides/#possible-extension-custom-attacks","title":"Possible Extension: Custom Attacks","text":"<p>Custom attacks can be implemented by using the <code>Attack</code> interface.</p>"}]}